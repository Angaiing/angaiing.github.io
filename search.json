[{"title":"九月十四日夜行珠江畔","url":"/post/7f55bce6.html","content":"2025-9-14 晚\n夜行珠江畔，迎面江风拂。\n广州市天河区沿江西路\n\n    [{\"url\":\"https://img.angaiing.top/IMG_20250914_214727.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250921_211426.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250921_211932.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250921_211943.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250921_213219.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250914_202420.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250914_205945.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250914_211616.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250914_213224.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250914_213511.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250914_213545.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250914_213611.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250914_214228.webp\",\"alt\":\"\",\"title\":\"\"}]\n  \n","categories":["散步"],"tags":["随手拍"]},{"title":"《酉阳杂俎》阅读笔记","url":"/post/d2b7ae7b.html","content":"《酉阳杂俎》读书笔记\n之前在知乎上偶然间刷到了一篇关于酉阳杂俎的文章，觉得很是有趣，趁着去广州购书中心的机会便买了下来。本身内容繁杂，长短不一，慢慢读吧。\n作者简介\n本书作者段成式（803？——863），字柯古，祖籍临淄。段成式出身望族。其六世祖段志玄（598——642）是唐朝开国元勋，官至右卫大将军，封褒国公，为凌烟阁二十四功臣之一，陪葬昭陵。其父段文昌（773——835）为中唐名臣，穆宗时曾为中书侍郎、同中书门下平章事，文宗时进封邹平郡公，历镇淮南、荆南、剑南西川。其母则是中唐名相武元衡之女。\n段文昌于唐德宗贞元十五年（799）入剑南西川节度使韦皋幕府。段成式即出生于成都，青少年时随父侍宦，辗转于长安和成都，江东和西蜀之间。\n","categories":["阅读笔记","酉阳杂俎"],"tags":["阅读","古文"]},{"title":"《水流云在：我的西南联大岁月》阅读笔记","url":"/post/2bb93c7b.html","content":"《水流云在：我的西南联大岁月》读书笔记\n本书是汪曾祺的散文集，以人民文学出版社《汪曾祺全集》散文卷为底本，主要以对大学青春岁月的回忆为主体。2025年上半年购于广州购书中心天河店，具体日期记不太清了。\n师恩母爱 ——怀念王文英老师\n在读到 “师恩母爱 ——怀念王文英老师” 这一章的这一段时，颇为感动， 泪难自禁。\n\n1981 年秋，我应邀回阔别多年的家乡讲学，带了一点北京的果脯去看王先生和张先生，并给他们各送了一首在招待所急就的诗。给王先生的一首不文不白，毫无雕饰。第二天张先生带了两瓶酒到招待所来看我，我说哪有老师来看学生的道理，还带了酒！张先生说，是王先生一定要他送来的。说王先生看了我的诗，哭了一晚上。这首诗全诗是：\n小孩子乖乖，把门儿开开，歌声犹在，耳边徘徊。我今亦老矣，白髭盈腮，念一生美育，从此培栽，师恩母爱，岂能忘怀！愿吾师康健，长寿无灾。\n张先生说，王先生对他说：“我教那么多学生，长大了，还没有一个来看过我的！”王先生指着收“师恩母爱，岂能忘怀”对张先生收：“他进幼稚园的时候还戴着他妈妈的孝！”我这才知道王先生为什么对我特别关心，特别喜爱。张先生反复念了这两句，连说：“师恩母爱！师恩母爱！”\n\n“我今亦老矣，白髭盈腮，念一生美育，从此培栽，师恩母爱，岂能忘怀！”\n觅我游踪五十年\n\n将去云南，临行前的晚上，写了三首旧体诗。怕到了那里，有朋友叫写字，临时想不出合适词句。一九八七年去云南，一路写了不少字，平地抠饼，现想词儿，深以为苦。其中一首是：\n羁旅天南久未还，故乡无此好湖山。长堤柳色浓如许，觅我游踪五十年。\n\n","categories":["阅读笔记","水流云在：我的西南联大岁月"],"tags":["阅读","汪曾祺"]},{"title":"维护日志","url":"/post/ffcd24f1.html","content":"维护日志\n2025-10-13\n使用 hexo 和 butterfly 主题搭建了一个简单的静态个人博客，部署在 github pages，目前没有什么内容，希望以后能够坚持记录。\n2025-10-14\n稍微修改了一些设置，本来想将图片托管在图床上的，尝试使用 github+picgo，但效果不太行，尝试了下 cloudfare r2，等以后图片多起来了再试试吧。\n2025-10-15\n\n\n使用 cloudflare r2 + picgo 终于把图床搞好了，用的是picgo-plugin-cloudflare-r2这个插件，感谢作者！\n\n\n修改了一些 css 样式。在页脚底部添加了计时器。\n\n\n在 Vercel 和 MongoDB Atlas 上部署了 Twikoo 评论系统，具体教程在Twikoo 官方文档上写得很详细了，还可以参考以下两篇博客。\n\n\n【Vercel】Twikoo | 为你的 HEXO 加入评论系统\n\n\nHEXO 系列教程 | 在 Butterfly 主题中使用评论系统 twikoo\n\n\n\n\n2025-10-16\n\n在阿里云上 14 块钱买了一个一年的域名，添加了 Cloudflare DNS。\n在测试的时候发现国内访问太慢了，将网站从 github pages 迁移到了 netlify。结果突然发现 netlify 免费用户每月只有 300 积分，而每一次构建都要 15 积分……，最后还是迁移回 github pages。\n\n2025-10-17\n\n更换 CDN 为 jsdmirror，发现有些资源没有，换回了 jsdeliver。\n在 Vercel 上绑定了自己的域名，加快国内访问速度，具体可以参见这篇博客解决 Vercel 被墙导致 Twikoo 无法评论的问题：在 Vercel 添加子域名。\n\n2025-10-18\n\n添加了星空背景特效\n\n2025-10-19\n\n添加了萌 IPC 备案\n添加了 wizard 加载动画和 gulp 优化，具体可参见这篇博客hexo 博客 butterfly 主题安装及魔改笔记。\n\n","categories":["维护日志"],"tags":["本站相关","日志"]},{"title":"计组——汇编学习笔记","url":"/post/3a831366.html","content":"计组——汇编学习\n本文与著名的《深入理解计算机系统》（CS:APP）一书一样，汇编代码格式采用 AT&amp;T 格式。\nAT&amp;T 格式与 Intel 格式的不同\n\n\n\n特性\nAT&amp;T 格式\nIntel 格式\n\n\n\n\n操作数顺序\nop s,d源在左，目标在右\nop d,s目标在左，源在右\n\n\n寄存器表示\nmov %ebx,%eax寄存器名称前加 %\nmov ebx,eax不带前缀\n\n\n立即数表示\nmov $985,%eax立即数前加 $\nmov 985,%eax不带前缀\n\n\n主存地址表示\n(af996h)用小括号\n[af996h]用中括号\n\n\n读写长度表示\nmovl，movqb、w、l、q 分别表示 1、2、4、8 字节\nmov byte ptr [af996h],5在主存地址前说明读写长度\n\n\n主存偏移表示\n偏移(基址, 索引, 缩放)8(%ebp)(%eax, %ebx, 4)\n[基址 + 索引 * 缩放 + 偏移][ebp + 8][eax + ebx * 4]\n\n\n注释\n#\n;\n\n\n\n内存寻址\n在 AT&amp;T 语法中，一个完整的内存地址表达式格式为：\n$$\nD(R_b, R_i, S)\n$$\n计算出的内存地址为：\n$$\n\\text{内存地址} = D + R_b + R_i \\times S\n$$\n各部分的含义：\n\n$D$（Displacement / 偏移量）：一个常数值（例如 8、-12，或标签 my_var 的地址），类似于“基础”的门牌号。\n$R_b$（Base Register / 基址寄存器）：一个寄存器（例如 %ebp、%eax、%rbx），提供“动态的”基准地址，如函数栈帧的开始或数组的开头。\n$R_i$（Index Register / 索引寄存器）：另一个寄存器（例如 %ecx、%eax），通常用于存储“索引”值，如循环变量 i。\n$S$（Scale / 缩放因子）：一个固定的乘数，值必须是 1、2、4 或 8。它配合索引（$R_i$）使用。如果 $R_i$ 存储数组下标 i，而数组元素大小为 4 字节（int），则 $S$ 应为 4，这样 Ri * S 就等于 i * 4，即第 i 个元素的字节偏移。\n\n常用汇编指令\n数据传送指令\n这类指令负责在寄存器和内存之间移动数据，是所有程序的基础。\n1. mov（Move）\n\n\n功能：将源操作数的值复制到目标操作数。这是最常用、最重要的指令。\n\n\nAT&amp;T 格式：movl source, destination\n\n\n示例：\nmovl %eax, %ebx      # 将寄存器 %eax 的值复制到 %ebxmovl $10, %eax       # 将立即数 10 存入寄存器 %eaxmovl (%ebx), %eax    # 将 %ebx 寄存器指向的内存地址中的数据加载到 %eaxmovl %eax, -4(%rbp)  # 将 %eax 的值存入栈上地址为 %rbp-4 的位置\n\n\n2. lea（Load Effective Address）\n\n\n功能：计算源操作数（必须是内存地址）的有效地址，并将其加载到目标操作数（必须是寄存器）。它传送的是地址本身，而不是地址指向的数据。\n\n\nAT&amp;T 格式：leaq source_address, destination_register\n\n\n示例：\nleaq -8(%rbp), %rax  # 将内存地址 %rbp-8 这个地址值本身加载到 %rax 寄存器                     # 这条指令执行后，%rax 的值就是 %rbp 的值减 8\n\n\n说明：lea 指令非常灵活，常被用来进行不影响标志位的快速算术运算。\n\n\n3. push / pop（Push / Pop）\n\n\n功能：在栈上压入或弹出数据。栈是“后进先出”（LIFO）的数据结构，在函数调用中至关重要。\n\n\npush：将操作数压入栈顶，栈指针 %rsp 会减小。\n\n\npop：从栈顶弹出一个数据到操作数，栈指针 %rsp 会增大。\n\n\nAT&amp;T 格式：pushq source / popq destination\n\n\n示例：\npushq %rbx           # 将 %rbx 的值压入栈顶popq %rax            # 从栈顶弹出一个值到 %rax\n\n\n算术运算指令\n用于执行基本的数学计算。\n1. add / sub（Add / Subtract）\n\n\n功能：加法和减法。\n\n\nAT&amp;T 格式：addl source, destination（结果：destination = destination + source）\n\n\n示例：\naddl %eax, %ebx      # %ebx = %ebx + %eaxsubl $5, %ecx        # %ecx = %ecx - 5\n\n\n2. inc / dec（Increment / Decrement）\n\n\n功能：将操作数加一或减一。比 add 或 sub 更高效。\n\n\nAT&amp;T 格式：incl destination\n\n\n示例：\nincl %eax            # %eax = %eax + 1decq %rbx            # %rbx = %rbx - 1\n\n\n3. imul（Signed Multiply）\n\n\n功能：有符号整数乘法。\n\n\nAT&amp;T 格式：imull source, destination（结果：destination = destination * source）\n\n\n示例：\nimull %ebx, %eax     # %eax = %eax * %ebx\n\n\n4. idiv（Signed Divide）\n\n\n功能：有符号整数除法。这个指令比较特殊。\n\n\nAT&amp;T 格式：idivl divisor\n\n\n说明：idiv 会使用 %edx:%eax（一个 64 位数）作为被除数，除数是指令的操作数。商存储在 %eax 中，余数存储在 %edx 中。\n\n\n示例：\ncqto                 # 64 位模式下，将 %rax 符号扩展到 %rdx:%raxidivq %rbx           # (%rdx:%rax) / %rbx，商在 %rax，余数在 %rdx\n\n\n注意：在执行 32 位除法 idivl 前，通常需要 cdq 指令将 %eax 符号扩展到 %edx。\n\n\n逻辑与比较指令\n1. and / or / xor (Bitwise AND / OR / XOR)\n\n\n功能: 按位进行与、或、异或运算。\n\n\nAT&amp;T 格式: andl source, destination (结果: destination = destination &amp; source)\n\n\n示例:\nandl $0xf, %eax      # 清零 %eax 的高28位，保留低4位xorl %eax, %eax      # 一种将 %eax 清零的高效方法\n\n\n2. cmp（Compare）\n\n基本含义：cmp 指令对两个操作数执行一次“隐藏”的减法操作（Destination - Source），但不保存结果，仅根据结果设置 EFLAGS 寄存器中的标志位。\n语法格式：cmp Source, Destination\n影响的标志位：\n\nZF（Zero Flag - 零标志位）：如果相减结果为 0（即两个数相等），ZF 设为 1；否则为 0。\nSF（Sign Flag - 符号标志位）：如果结果为负数，SF 设为 1；否则为 0。\nCF（Carry Flag - 进位标志位）：用于无符号数比较。如果减法产生了借位（Destination &lt; Source），CF 设为 1。\nOF（Overflow Flag - 溢出标志位）：用于有符号数比较。如果减法导致有符号溢出，OF 设为 1。\n\n\n\n3. test（Test）\n\n基本含义：test 指令对两个操作数执行“隐藏”的按位与操作（Destination &amp; Source），但不保存结果，仅根据结果设置标志位。\n语法格式：test Source, Destination\n典型用途：检查一个数中的特定位是否为 1，或判断一个数是否为 0。例如，test %eax, %eax 可以快速判断 %eax 是否为 0。\n影响的标志位：\n\nZF（Zero Flag）：如果按位与的结果为 0，ZF 设为 1；否则为 0。\nSF（Sign Flag）：如果结果的最高位为 1（即负数），SF 设为 1；否则为 0。\nCF 和 OF 会被清零。\n\n\n\n控制流指令\n1. jmp（Unconditional Jump）- 无条件跳转\n\n基本含义：立即、无条件地将程序执行流转移到指定的标签（label）位置。\n语法格式：jmp label\n典型用途：用于 else 块执行后跳过 if 块，或构成循环。\n\n2. jcc（Conditional Jumps）- 条件跳转命令\n\n基本含义：这一系列命令会检查 EFLAGS 寄存器的特定标志位，如果满足条件，则跳转到指定标签；否则，顺序执行下一条指令。\n语法格式：j&lt;condition&gt; label\n\n常见条件跳转命令汇总\n\n\n\n命令\n描述（Jump if…）\n检查的标志位\n适用场景\n\n\n\n\n相等/零\n\n\n\n\n\nje\nEqual（相等）\nZF = 1\na == b\n\n\njne\nNot Equal（不相等）\nZF = 0\na != b\n\n\n有符号比较\n\n\n\n\n\njg\nGreater（大于）\nZF=0 and SF=OF\nsigned a &gt; b\n\n\njge\nGreater or Equal（大于等于）\nSF = OF\nsigned a &gt;= b\n\n\njl\nLess（小于）\nSF ≠ OF\nsigned a &lt; b\n\n\njle\nLess or Equal（小于等于）\nZF=1 or SF≠OF\nsigned a &lt;= b\n\n\n无符号比较\n\n\n\n\n\nja\nAbove（之上）\nCF=0 and ZF=0\nunsigned a &gt; b\n\n\njae\nAbove or Equal（之上或等于）\nCF = 0\nunsigned a &gt;= b\n\n\njb\nBelow（之下）\nCF = 1\nunsigned a &lt; b\n\n\njbe\nBelow or Equal（之下或等于）\nCF=1 or ZF=1\nunsigned a &lt;= b\n\n\n\n3. call / ret (Call / Return)\n\n\n功能: 用于函数（或子程序）的调用和返回。\n\n\ncall: 将下一条指令的地址压入栈中（作为返回地址），然后跳转到函数的起始地址。\n\n\nret: 从栈顶弹出返回地址，并跳转到该地址，从而返回到调用者。\n\n\n示例:\ncall my_function     # 调用名为 my_function 的函数# ... my_function 执行完毕后，会从这里继续执行my_function:    # ... 函数体 ...    ret              # 从函数返回\n\n\n4. cmovcc（Conditional Move，条件传送）指令\n\n基本含义：检查 EFLAGS 寄存器的特定标志位，如果满足条件，则执行 mov Source, Destination 操作。如果标志位不满足条件，该指令就变成一个空操作（NOP），不执行任何数据传送，Destination 的值保持不变。\n语法格式：cmov&lt;condition&gt; Source, Destination\n与条件跳转的对比：cmov 可以避免分支预测失败带来的性能损失，适用于简单的条件赋值。但如果条件分支的逻辑很复杂，使用条件跳转仍然是更好的选择。\n\n条件语句\n高级语言中的条件语句（如 if-else）是通过 cmp 或 test 指令与条件跳转指令（jcc）组合来实现的。其基本思想是：如果条件不满足，就跳过 if 块的代码。\n1. if 语句\nC 语言示例：\n// 假设 a 在 %eax, b 在 %ebxif (a &gt; b) &#123;    // body&#125;// next\n汇编实现：\n    cmp %ebx, %eax   # 比较 a 和 b (eax - ebx)    jle .L_end       # 如果 a &lt;= b (不满足 a &gt; b)，则跳转到结尾# if-body:    ...              # 条件满足时执行的代码.L_end:    ...              # 后续代码\n\n逻辑：先比较，然后使用与条件相反的跳转指令。如果 a &gt; b 的条件不成立（即 a &lt;= b），就跳过 if 的主体部分。\n\n2. if-else 语句\nC 语言示例：\n// 假设 a 在 %eax, b 在 %ebxif (a &gt; b) &#123;    // if-body&#125; else &#123;    // else-body&#125;// next\n汇编实现：\n    cmp %ebx, %eax   # 比较 a 和 b (eax - ebx)    jle .L_else      # 如果 a &lt;= b (不满足 a &gt; b)，则跳转到 else 块# if-body:    ...              # if 块的代码    jmp .L_end       # 执行完 if 块后，无条件跳转到结尾.L_else:# else-body:    ...              # else 块的代码.L_end:    ...              # 后续代码\n\n逻辑：\n\n比较 a 和 b。\n如果 if 的条件不满足，则跳转到 else 块（.L_else）。\n如果 if 的条件满足，则顺序执行 if 块的代码。\nif 块执行完毕后，必须用一个无条件跳转 jmp 来跳过 else 块，防止它被错误地执行。\n\n\n\n3. 使用 cmov 实现条件赋值\n对于简单的条件赋值，现代编译器倾向于使用 cmov 指令来代替条件跳转，以避免分支预测失败的性能开销。\nC 语言示例：\n// 计算 x 和 y 中的较大值int max(int x, int y) &#123;    return x &gt; y ? x : y;&#125;\n汇编实现（使用 cmov）：\n# x 在 %edi, y 在 %esi    movl %esi, %eax    # 先假设 y 是最大值，eax = y    cmpl %esi, %edi    # 比较 x 和 y    cmovg %edi, %eax   # 如果 x &gt; y (greater)，则将 x 的值赋给 eax    ret                # 返回 eax\n\n逻辑：这种实现方式没有跳转，代码是线性的。无论 x 和 y 的大小关系如何，执行的指令数量都是固定的，因此效率更高、更稳定。\n\n","categories":["学习笔记","计组","汇编"],"tags":["计组","汇编","学习"]}]