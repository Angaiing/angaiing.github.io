[{"title":"CSAPP 实验 2 ：Bomb Lab","url":"/post/50d220bf.html","content":"CSAPP 实验 2 ：Bomb Lab\n引言\nBomb Lab 实验文件目录如下\nbomb├── bomb├── bomb.c└── README\n\nbomb: 二进制可执行程序\nbomb: 程序的主函数 main 的源文件\nREADME: This is an x86-64 bomb for self-study students. \n\n阅读 bomb.c 文件\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;support.h&quot;#include &quot;phases.h&quot;/* * Note to self: Remember to erase this file so my victims will have no * idea what is going on, and so they will all blow up in a * spectaculary fiendish explosion. -- Dr. Evil */FILE *infile;int main(int argc, char *argv[])&#123;    char *input;    /* Note to self: remember to port this bomb to Windows and put a     * fantastic GUI on it. */    /* When run with no arguments, the bomb reads its input lines     * from standard input. */    if (argc == 1) &#123;\tinfile = stdin;    &#125;    /* When run with one argument &lt;file&gt;, the bomb reads from &lt;file&gt;     * until EOF, and then switches to standard input. Thus, as you     * defuse each phase, you can add its defusing string to &lt;file&gt; and     * avoid having to retype it. */    else if (argc == 2) &#123;\tif (!(infile = fopen(argv[1], &quot;r&quot;))) &#123;\t    printf(&quot;%s: Error: Couldn&#x27;t open %s\\n&quot;, argv[0], argv[1]);\t    exit(8);\t&#125;    &#125;    /* You can&#x27;t call the bomb with more than 1 command line argument. */    else &#123;\tprintf(&quot;Usage: %s [&lt;input_file&gt;]\\n&quot;, argv[0]);\texit(8);    &#125;    /* Do all sorts of secret stuff that makes the bomb harder to defuse. */    initialize_bomb();    printf(&quot;Welcome to my fiendish little bomb. You have 6 phases with\\n&quot;);    printf(&quot;which to blow yourself up. Have a nice day!\\n&quot;);    /* Hmm...  Six phases must be more secure than one phase! */    input = read_line();             /* Get input                   */    phase_1(input);                  /* Run the phase               */    phase_defused();                 /* Drat!  They figured it out!\t\t\t\t      * Let me know how they did it. */    printf(&quot;Phase 1 defused. How about the next one?\\n&quot;);    /* The second phase is harder.  No one will ever figure out     * how to defuse this... */    input = read_line();    phase_2(input);    phase_defused();    printf(&quot;That&#x27;s number 2.  Keep going!\\n&quot;);    /* I guess this is too easy so far.  Some more complex code will     * confuse people. */    input = read_line();    phase_3(input);    phase_defused();    printf(&quot;Halfway there!\\n&quot;);    /* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */    input = read_line();    phase_4(input);    phase_defused();    printf(&quot;So you got that one.  Try this one.\\n&quot;);    /* Round and &#x27;round in memory we go, where we stop, the bomb blows! */    input = read_line();    phase_5(input);    phase_defused();    printf(&quot;Good work!  On to the next...\\n&quot;);    /* This phase will never be used, since no one will get past the     * earlier ones.  But just in case, make this one extra hard. */    input = read_line();    phase_6(input);    phase_defused();    /* Wow, they got it!  But isn&#x27;t something... missing?  Perhaps     * something they overlooked?  Mua ha ha ha ha! */    return 0;&#125;\n可以发现，在 main 函数中，总共有 6 个相似的 phase，每个 phase 读入一行输入，并调用 phase 函数和phase_defused()函数判断是否成功拆弹。\n我们首先运行一下bomb程序，输入hello\n\n很显然炸弹爆炸了，我们的输入不符合要求。\n我们首先对bomb反汇编，输入命令objdump -d bomb &gt; bomb.asm，这行命令将bomb这个文件反汇编，并将结果保存到bomb.asm文件中。\n阅读bomb.asm文件，可以找到 6 个 phase\n0000000000400ee0 &lt;phase_1&gt;:  400ee0:\t48 83 ec 08          \tsub    $0x8,%rsp  400ee4:\tbe 00 24 40 00       \tmov    $0x402400,%esi  400ee9:\te8 4a 04 00 00       \tcall   401338 &lt;strings_not_equal&gt;  400eee:\t85 c0                \ttest   %eax,%eax  400ef0:\t74 05                \tje     400ef7 &lt;phase_1+0x17&gt;  400ef2:\te8 43 05 00 00       \tcall   40143a &lt;explode_bomb&gt;  400ef7:\t48 83 c4 08          \tadd    $0x8,%rsp  400efb:\tc3                   \tret0000000000400efc &lt;phase_2&gt;:......0000000000400f43 &lt;phase_3&gt;:......000000000040100c &lt;phase_4&gt;:......0000000000401062 &lt;phase_5&gt;:......00000000004010f4 &lt;phase_6&gt;:......\n将文件作为输入\n测试某个 phase 的答案时，运行bomb程序后都要手动重新输入前面几个 phase 的答案，这样未免太繁琐了，好在bomb文件中已经提示我们可以使用文件作为输入。\n我们在目录下创建一个txt文件，名字随意，我这里叫answer.txt，输入gdb bomb命令启动调试器，输入run answer.txt命令将answer.txt文件作为输入。\n基础知识\nGDB 调试器常用命令\n这一部分不用死记硬背，用到的时候查就可以了\n1. 启动与运行\n\n\n\n命令\n简写\n作用\n示例\n\n\n\n\ngdb \n\n启动调试器\ngdb bomb\n\n\nrun\nr\n开始运行程序\nr 或 r solution.txt\n\n\nkill\n\n停止正在运行的程序\nkill\n\n\nquit\nq\n退出 GDB\nq\n\n\n\n2. 断点控制\n\n\n\n命令\n简写\n作用\n示例\n\n\n\n\nbreak \nb\n在函数名或地址处设断点\nb phase_1 或 b *0x400ee0\n\n\ninfo break\ni b\n查看当前所有断点\ni b\n\n\ndelete \nd\n删除指定编号的断点\nd 1\n\n\nstepi\nsi\n单步执行（汇编级），遇到函数会进入\nsi\n\n\nnexti\nni\n单步跳过（汇编级），遇到函数不进入\nni\n\n\ncontinue\nc\n继续执行直到下一个断点\nc\n\n\n\n3. 查看代码与寄存器\n\n\n\n命令\n简写\n作用\n示例\n\n\n\n\ndisassemble\ndisas\n反汇编当前函数\ndisas 或 disas phase_1\n\n\ninfo registers\ni r\n查看所有寄存器的值\ni r\n\n\nprint $\np\n打印特定寄存器的值\np $rax\n\n\n\n4. 核心命令：查看内存 (x)\n格式： x /&lt;数量&gt;&lt;格式&gt;&lt;单位&gt; &lt;地址&gt;\n\n格式 (Format):\n\ns: 字符串 (String) —— 查看密码常用\nd: 十进制 (Decimal) —— 查看整数常用\nx: 十六进制 (Hex)\ni: 指令 (Instruction)\n\n\n单位 (Unit):\n\nb: 1 字节 (Byte)\nw: 4 字节 (Word) —— int 通常是这个\ng: 8 字节 (Giant) —— 指针通常是这个\n\n\n\nx86-64 寄存器\n\nphase_1\n我们首先逐行分析下汇编代码\n400ee0:\t48 83 ec 08          \tsub    $0x8,%rsp\n\n将栈顶指针减去 8，这不重要，略过\n\n400ee4:\tbe 00 24 40 00       \tmov    $0x402400,%esi\n\n\n将十六进制数0x402400存放到%esi寄存器中\n\n\n%esi寄存器是%rsi寄存器的低 32 位，相当于给函数第二个参数赋值\n\n\n那么函数的第一个参数是什么呢？\n\n在调用这个函数时，我们是这样执行的  phase_1(input)\n所以，第一个参数%rdi已经存放了我们的之前的输入\n\n\n\n400ee9:\te8 4a 04 00 00       \tcall   401338 &lt;strings_not_equal&gt;\n\n调用函数strings_not_equal\n看名字就知道，这个函数用来比较两个字符串是否相等\n\n400eee:\t85 c0                \ttest   %eax,%eax400ef0:\t74 05                \tje     400ef7 &lt;phase_1+0x17&gt;400ef2:\te8 43 05 00 00       \tcall   40143a &lt;explode_bomb&gt;\n\ntest: 检查返回值%eax是否为 0\nje(Jump if Equal): 如果等于 0，就跳转到400ef7，如果不等，那么跳过这行代码，执行下面的explode_bomb\n\n到这里我们可以推测strings_not_equal函数的判断条件\n\n如果两个字符串相等，返回 0，那么我们不会触发炸弹爆炸\n如果两个字符串不相等，返回 1，炸弹爆炸\n\n\n\n\n\n我们可以尝试将这段汇编代码整理成伪代码的形式\nvoid phase_1(rdi)&#123;\tesi = 0x402400;\tresult = stirng_not_equal(rdi,esi);\tif(result != 0)\t&#123;\t\texplode_bomb();\t&#125;\treturn;&#125;\n通过以上分析，我们可以发现，关键是内存地址0x402400\n输入命令x/s 0x402400，其中，x= eXamine (检查内存)，/s= String (按字符串格式显示)。\n\n我们可以发现，答案就是Border relations with Canada have never been better.\nphade_2\n我们首先将这段汇编代码初步处理成伪代码\nvoid phase_2(rdi)&#123;    rsp -= 0x28;    rsi = rsp;    read_six_numbers();    if(*rsp == 1)    \tgoto 400f30;    else        explode_bomb();    400f17:    \teax = *(rbx - 0x4);    \teax += eax;    \tif(eax == *rbx)            goto 400f25;    \telse            explode_bomb();    400f25:    \trbx += 0x4;    \tif(rbp != rbx)            goto 400f17;    \telse            goto 400f3c;    400f30:    \trbx = rsp + 0x4;    \trbp = rsp + 0x18;    \tgoto 400f17;    return;&#125;\n尝试阅读并理解这段代码，可以发现，其中蕴含着一个循环。我们作进一步整理。\nvoid phase_2(rdi)&#123;    rsp -= 0x28; // 栈顶指针减0x28，在栈上开辟空间    rsi = rsp;    read_six_numbers(rdi,rsi);    if(*rsp != 1) explode_bomb();    // 初始化，400f30    rbx = rsp + 0x4;    rbp = rsp + 0x18;    while(rbp != rbx) //判断    &#123;        // 进入循环体,400f17        eax = *(rbx - 0x4);    \teax += eax;    \tif(eax != *rbx) explode_bomb();        rbx += 0x4; // 更新步进，400f25    &#125;    return;&#125;\n整理后，此时就比较好理解了\n\n\nread_six_numbers(rdi,rsi);函数读取我们的输入，并将其写到之前开辟栈空间上。\nrsp -= 0x28;在栈上开辟了一块空间。\n\nrbp为高位指针，初始指向rsp + 0x18\nrbx为低位指针，初始指向rsp + 0x4\n\n\nrsp指向栈底，*rsp为 1\nrbx每次增加0x4，直到rbp == rbx，总计循环 5 次\neax等于*(rbx-0x4)，由低位到高位每隔0x4逐步遍历，初始为 1 ，从 2 开始检查，每次倍增，一共循环五次\n\n所以栈上的数字应该是1 2 4 8 16 32。\nphase_3\n我们一步步来分析 phase_3 的汇编代码\n0000000000400f43 &lt;phase_3&gt;:  400f43:\t48 83 ec 18          \tsub    $0x18,%rsp\t\t\t\t;开辟栈空间  400f47:\t48 8d 4c 24 0c       \tlea    0xc(%rsp),%rcx\t\t\t;第四个参数，不妨称其为y  400f4c:\t48 8d 54 24 08       \tlea    0x8(%rsp),%rdx\t\t\t;第三个参数，不妨称其为x  400f51:\tbe cf 25 40 00       \tmov    $0x4025cf,%esi  400f56:\tb8 00 00 00 00       \tmov    $0x0,%eax  400f5b:\te8 90 fc ff ff       \tcall   400bf0 &lt;__isoc99_sscanf@plt&gt;\t;调用sscanf函数  400f60:\t83 f8 01             \tcmp    $0x1,%eax\t\t\t\t;比较sscanf返回值与1  400f63:\t7f 05                \tjg     400f6a &lt;phase_3+0x27&gt;\t;如果返回值大于1，跳转  400f65:\te8 d0 04 00 00       \tcall   40143a &lt;explode_bomb&gt;\t;如果返回值小于等于1，炸弹爆炸  400f6a:\t83 7c 24 08 07       \tcmpl   $0x7,0x8(%rsp)\t\t\t;比较x与7  400f6f:\t77 3c                \tja     400fad &lt;phase_3+0x6a&gt;\t;如果大于则爆炸  400f71:\t8b 44 24 08          \tmov    0x8(%rsp),%eax\t\t\t;把x放入%eax  400f75:\tff 24 c5 70 24 40 00 \tjmp    *0x402470(,%rax,8)\t\t;间接跳转  400f7c:\tb8 cf 00 00 00       \tmov    $0xcf,%eax\t\t\t\t;%eax等于207  400f81:\teb 3b                \tjmp    400fbe &lt;phase_3+0x7b&gt;  400f83:\tb8 c3 02 00 00       \tmov    $0x2c3,%eax  400f88:\teb 34                \tjmp    400fbe &lt;phase_3+0x7b&gt;  400f8a:\tb8 00 01 00 00       \tmov    $0x100,%eax  400f8f:\teb 2d                \tjmp    400fbe &lt;phase_3+0x7b&gt;  400f91:\tb8 85 01 00 00       \tmov    $0x185,%eax  400f96:\teb 26                \tjmp    400fbe &lt;phase_3+0x7b&gt;  400f98:\tb8 ce 00 00 00       \tmov    $0xce,%eax  400f9d:\teb 1f                \tjmp    400fbe &lt;phase_3+0x7b&gt;  400f9f:\tb8 aa 02 00 00       \tmov    $0x2aa,%eax  400fa4:\teb 18                \tjmp    400fbe &lt;phase_3+0x7b&gt;  400fa6:\tb8 47 01 00 00       \tmov    $0x147,%eax  400fab:\teb 11                \tjmp    400fbe &lt;phase_3+0x7b&gt;  400fad:\te8 88 04 00 00       \tcall   40143a &lt;explode_bomb&gt;  400fb2:\tb8 00 00 00 00       \tmov    $0x0,%eax  400fb7:\teb 05                \tjmp    400fbe &lt;phase_3+0x7b&gt;  400fb9:\tb8 37 01 00 00       \tmov    $0x137,%eax  400fbe:\t3b 44 24 0c          \tcmp    0xc(%rsp),%eax\t\t\t;比较y和%eax  400fc2:\t74 05                \tje     400fc9 &lt;phase_3+0x86&gt;\t;如果相等，过关  400fc4:\te8 71 04 00 00       \tcall   40143a &lt;explode_bomb&gt;\t;否则爆炸  400fc9:\t48 83 c4 18          \tadd    $0x18,%rsp  400fcd:\tc3                   \tret\n我们首先注意到\n400f5b:\te8 90 fc ff ff       \tcall   400bf0 &lt;__isoc99_sscanf@plt&gt;\n这里调用了sscnaf函数，sscanf的 C 语言函数签名为int sscanf(const char *str, const char *format, ...)，返回值表示成功匹配并赋值的参数个数。\n又注意到\n400f51:\tbe cf 25 40 00       \tmov    $0x4025cf,%esi\n%esi寄存器存储第二个参数，即sscanf函数的格式化字符串，在终端中输入x/s 0x4025cf，发现终端输出\n(gdb) x/s 0x4025cf0x4025cf:       &quot;%d %d&quot;\n这表明sscanf函数的第二个参数格式化字符串为两个整数，说明函数的第三和第四个参数，即要写入的变量是两个整数。\n我们又知道，通常第三和第四个参数用%rdx和%rcx寄存器存储，注意到这两行\n400f47:\t48 8d 4c 24 0c       \tlea    0xc(%rsp),%rcx400f4c:\t48 8d 54 24 08       \tlea    0x8(%rsp),%rdx\n\n\nlea（Load Effective Address) 是取地址\n\n\n第三个参数%rdx对应第一个%d，表明这里存储的地址是栈地址%rsp + 12\n\n\n第四个参数%rcx对应第二个%d，表明这里存储的地址是栈地址%rsp + 8\n\n\n这两个地址是sscanf函数将要写入的地方，我们不妨称其为x和y\n\n\n我们接着来看\n400f60:\t83 f8 01             \tcmp    $0x1,%eax400f63:\t7f 05                \tjg     400f6a &lt;phase_3+0x27&gt;400f65:\te8 d0 04 00 00       \tcall   40143a &lt;explode_bomb&gt;\n这里对sscanf函数的返回值做比较，如果返回值大于 1，跳转到400f6a，否则炸弹爆炸。\n我们继续向下看\n400f6a:\t83 7c 24 08 07       \tcmpl   $0x7,0x8(%rsp)\t\t\t;比较x与7400f6f:\t77 3c                \tja     400fad &lt;phase_3+0x6a&gt;\t;如果大于则爆炸400f71:\t8b 44 24 08          \tmov    0x8(%rsp),%eax\t\t\t;把x放入%eax\n这说明x必须是 0 到 7 之间的一个数字(ja 用于无符号数的比较)，\n跳转表\n400f75:\tff 24 c5 70 24 40 00 \tjmp    *0x402470(,%rax,8)\t\t;间接跳转\n\n这个指令会不是跳转到一个固定的地址，而是先计算出一个地址再跳转\nAddress = *(0x402470 + %rax + 8)\n0x402470是一个数组起始地址\n%rax是一个索引\n8是因为在 64 位系统中，内存地址占 8 个字节\n\n注意到我们之前已经将把x放入%eax中了，所以这里会根据我们输入的x的值，来决定跳转到哪里\n我们打开gdb调试器，输入x/8xg 0x402470\n\n8表示显示数量，显示 8 个内存单元\nx表示显示格式，显示十六进制\ng表达数据大小，(Giant words)表示 8 个字节\n\n可以看到终端输出\n0x402470:       0x0000000000400f7c      0x0000000000400fb90x402480:       0x0000000000400f83      0x0000000000400f8a0x402490:       0x0000000000400f91      0x0000000000400f980x4024a0:       0x0000000000400f9f      0x0000000000400fa6\ngdb调试器为了节省空间，每行展示了两个内存值，完整显示是这样的\n0x402470:       0x0000000000400f7c0x402478:       0x0000000000400fb90x402480:       0x0000000000400f830x402488:       0x0000000000400f8a0x402490:       0x0000000000400f910x402498:       0x0000000000400f980x4024a0:       0x0000000000400f9f0x4024a8:       0x0000000000400fa6\n这样就很清晰了，这说明我们输入的x索引要跳转到的对应的内存地址\n我们接着往下看\n400f7c:\tb8 cf 00 00 00       \tmov    $0xcf,%eax400f81:\teb 3b                \tjmp    400fbe &lt;phase_3+0x7b&gt;400f83:\tb8 c3 02 00 00       \tmov    $0x2c3,%eax400f88:\teb 34                \tjmp    400fbe &lt;phase_3+0x7b&gt;400f8a:\tb8 00 01 00 00       \tmov    $0x100,%eax400f8f:\teb 2d                \tjmp    400fbe &lt;phase_3+0x7b&gt;400f91:\tb8 85 01 00 00       \tmov    $0x185,%eax400f96:\teb 26                \tjmp    400fbe &lt;phase_3+0x7b&gt;400f98:\tb8 ce 00 00 00       \tmov    $0xce,%eax400f9d:\teb 1f                \tjmp    400fbe &lt;phase_3+0x7b&gt;400f9f:\tb8 aa 02 00 00       \tmov    $0x2aa,%eax400fa4:\teb 18                \tjmp    400fbe &lt;phase_3+0x7b&gt;400fa6:\tb8 47 01 00 00       \tmov    $0x147,%eax400fab:\teb 11                \tjmp    400fbe &lt;phase_3+0x7b&gt;\n这里的代码结构高度相似，都是先给%eax赋一个值，再跳转到400fbe\n结合前一步分析，我们可以得出以下映射表\n\n\n\n输入 x (%rax)\n内存地址\n跳转目标\n对应逻辑\n\n\n\n\n0\n0x402470\n0x400f7c\nmov $0xcf, %eax -&gt; 207\n\n\n1\n0x402478\n0x400fb9\nmov $0x137, %eax -&gt; 311\n\n\n2\n0x402480\n0x400f83\nmov $0x2c3, %eax -&gt; 707\n\n\n3\n0x402488\n0x400f8a\nmov $0x100, %eax -&gt; 256\n\n\n4\n0x402490\n0x400f91\nmov $0x185, %eax -&gt; 389\n\n\n5\n0x402498\n0x400f98\nmov $0xce, %eax -&gt; 206\n\n\n6\n0x4024a0\n0x400f9f\nmov $0x2aa, %eax -&gt; 682\n\n\n7\n0x4024a8\n0x400fa6\nmov $0x147, %eax -&gt; 327\n\n\n\n最后比较输入y和%eax，如果相等则过关，否则炸弹爆炸\n400fbe:\t3b 44 24 0c          \tcmp    0xc(%rsp),%eax400fc2:\t74 05                \tje     400fc9 &lt;phase_3+0x86&gt;400fc4:\te8 71 04 00 00       \tcall   40143a &lt;explode_bomb&gt;\n综合以上分析，答案呼之欲出，我们要输入两个数字x和y，x为 0 到 7 之间的一个整数，y为与之对应的一个整数\n随意填入以下一组数据即可\n\n0 207\n1 311\n2 707\n3 256\n4 389\n5 206\n6 682\n7 327\n\nphase_4\n000000000040100c &lt;phase_4&gt;:  40100c:\t48 83 ec 18          \tsub    $0x18,%rsp  401010:\t48 8d 4c 24 0c       \tlea    0xc(%rsp),%rcx\t\t\t\t;第二个数y的地址  401015:\t48 8d 54 24 08       \tlea    0x8(%rsp),%rdx\t\t\t\t;第一个数x的地址  40101a:\tbe cf 25 40 00       \tmov    $0x4025cf,%esi\t\t\t\t;&quot;%d %d&quot;  40101f:\tb8 00 00 00 00       \tmov    $0x0,%eax  401024:\te8 c7 fb ff ff       \tcall   400bf0 &lt;__isoc99_sscanf@plt&gt;\t;调用函数sscanf  401029:\t83 f8 02             \tcmp    $0x2,%eax\t\t\t\t\t;比较返回值%eax与2  40102c:\t75 07                \tjne    401035 &lt;phase_4+0x29&gt;\t\t;如果不相等则跳转  40102e:\t83 7c 24 08 0e       \tcmpl   $0xe,0x8(%rsp)\t\t\t\t;比较14和x  401033:\t76 05                \tjbe    40103a &lt;phase_4+0x2e&gt;\t\t;jump if below or equal  401035:\te8 00 04 00 00       \tcall   40143a &lt;explode_bomb&gt;\t\t;如果大于则爆炸  40103a:\tba 0e 00 00 00       \tmov    $0xe,%edx\t\t\t\t\t;%edx = 14  40103f:\tbe 00 00 00 00       \tmov    $0x0,%esi\t\t\t\t\t;%esi = 0  401044:\t8b 7c 24 08          \tmov    0x8(%rsp),%edi\t\t\t\t;%edi = x  401048:\te8 81 ff ff ff       \tcall   400fce &lt;func4&gt;\t\t\t\t;调用函数func4  40104d:\t85 c0                \ttest   %eax,%eax\t\t\t\t\t;检查%eax是否为0  40104f:\t75 07                \tjne    401058 &lt;phase_4+0x4c&gt;\t\t;如果非0，炸弹爆炸  401051:\t83 7c 24 0c 00       \tcmpl   $0x0,0xc(%rsp)\t\t\t\t;比较y和0  401056:\t74 05                \tje     40105d &lt;phase_4+0x51&gt;\t\t;如果相等，过关  401058:\te8 dd 03 00 00       \tcall   40143a &lt;explode_bomb&gt;\t\t;否则，炸弹爆炸  40105d:\t48 83 c4 18          \tadd    $0x18,%rsp  401061:\tc3                   \tret\n这里前面和phase_3类似，不再赘述\n同样的，我们要输入两个整数x和y，x必须在 0 到 14 之间\n注意，这里调用了一个函数func4，传入的参数分别为x，0，14，且func4返回值必须为 0\n40103a:\tmov    $0xe,%edx            ; 参数 3 (%edx) = 1440103f:\tmov    $0x0,%esi            ; 参数 2 (%esi) = 0401044:\tmov    0x8(%rsp),%edi       ; 参数 1 (%edi) = x401048:\tcall   400fce &lt;func4&gt;       ; 调用 func4(x, 0, 14)40104d:\t85 c0                \ttest   %eax,%eax\t\t\t\t\t;检查%eax是否为040104f:\t75 07                \tjne    401058 &lt;phase_4+0x4c&gt;\t\t;如果非0，炸弹爆炸\n我们接着往下看\n401051:\t83 7c 24 0c 00       \tcmpl   $0x0,0xc(%rsp)\t\t\t\t;比较y和0401056:\t74 05                \tje     40105d &lt;phase_4+0x51&gt;\t\t;如果相等，过关401058:\te8 dd 03 00 00       \tcall   40143a &lt;explode_bomb&gt;\t\t;否则，炸弹爆炸\n这里我们可以推断第二个输入y必须为0\n那么接下来的问题就是x了，让我们来看看函数func4的代码\n\n%edi = 第 1 个参数 x\n%esi = 第 2 个参数 0\n%edx = 第 3 个参数 14\n\n0000000000400fce &lt;func4&gt;:  400fce:\t48 83 ec 08          \tsub    $0x8,%rsp  400fd2:\t89 d0                \tmov    %edx,%eax\t\t\t;%eax = %edx  400fd4:\t29 f0                \tsub    %esi,%eax\t\t\t;%eax -= %esi  400fd6:\t89 c1                \tmov    %eax,%ecx\t\t\t;%ecx = %eax  400fd8:\tc1 e9 1f             \tshr    $0x1f,%ecx\t\t\t;逻辑右移，提出符号位  400fdb:\t01 c8                \tadd    %ecx,%eax\t\t\t;%eax += %ecx  400fdd:\td1 f8                \tsar    $1,%eax\t\t\t\t;%eax /= 2，算术右移  400fdf:\t8d 0c 30             \tlea    (%rax,%rsi,1),%ecx\t;ecx = eax + esi  400fe2:\t39 f9                \tcmp    %edi,%ecx  400fe4:\t7e 0c                \tjle    400ff2 &lt;func4+0x24&gt;  400fe6:\t8d 51 ff             \tlea    -0x1(%rcx),%edx  400fe9:\te8 e0 ff ff ff       \tcall   400fce &lt;func4&gt;  400fee:\t01 c0                \tadd    %eax,%eax  400ff0:\teb 15                \tjmp    401007 &lt;func4+0x39&gt;  400ff2:\tb8 00 00 00 00       \tmov    $0x0,%eax  400ff7:\t39 f9                \tcmp    %edi,%ecx  400ff9:\t7d 0c                \tjge    401007 &lt;func4+0x39&gt;  400ffb:\t8d 71 01             \tlea    0x1(%rcx),%esi  400ffe:\te8 cb ff ff ff       \tcall   400fce &lt;func4&gt;  401003:\t8d 44 00 01          \tlea    0x1(%rax,%rax,1),%eax  401007:\t48 83 c4 08          \tadd    $0x8,%rsp  40100b:\tc3                   \tret\n我们将以上汇编代码整理成伪代码的形式\nint func4(int x, int a, int b)&#123;    eax = b - a;    ecx = eax;    eax /= 2;    ecx = eax + a * 1;  // ecx = ( b - a ) / 2 + a    if(ecx &lt;= x)    &#123;        if(ecx &gt;= x)        &#123;            // 也就是 ecx == x            return 0;        &#125;        else        &#123;            // ecx &lt; x，递归调用func4            result = func4(x, ecx + 1, b);            return 1 + 2 * result;        &#125;    &#125;    else    &#123;        // ecx &gt; x，递归调用func4        result = func4(x, a, ecx - 1);        return 2 * result;    &#125;&#125;\n到这里就很清楚了，这是一个二分查找的递归函数，ecx 就是 mid，如果\n\n如果 mid == x，返回 0。\n如果 mid &gt; x，返回 2 * 子结果。\n如果 mid &lt; x，返回 2 * 子结果 + 1。\n\n我们前面提到过，func4函数返回值必须为0，那么返回值如何为 0 呢？就是在二分的过程中，x必须一直在左半边( &lt; mid )，或者x= mid，因为一旦x位于右半边，结果+1，就不可能为 0 了。\n所以我们现在要找到一个x使得在二分0到14的情况下，要么 x &lt; mid，要么x == mid。\n下面我们来手动算一下\n\nleft = 0, right = 14\n\nmid = 0 + ( 14 - 0 ) / 2 = 7\n若 x = 7，mid == x，返回 0\n若 x &lt; 7 ，递归调用 func4(x, 0, 6)\n\n\nleft = 0, right = 6\n\nmid = 0 + ( 6 - 0 ) / 2 = 3\n若 x = 3, mid == x，返回 0\n若 x &lt; 3 ，递归调用 func4(x, 0, 2)\n\n\nleft = 0, right = 2\n\nmid = 0 + ( 2 - 0 ) / 2 = 1\n若 x = 1, mid == x，返回 0\n若 x &lt; 1( x == 0 ) ，递归调用 func4(x, 0, 0)\n\n\nleft = 0, right = 0\n\nmid = 0 + ( 0 - 0 ) / 2 = 0\n若 x = 0，mid == x，返回 0\n\n\n\n综上，我们最终的答案(x，y)是\n\n7 0\n3 0\n1 0\n0 0\n\nphase_5\n0000000000401062 &lt;phase_5&gt;:  401062:\t53                   \tpush   %rbx  401063:\t48 83 ec 20          \tsub    $0x20,%rsp  401067:\t48 89 fb             \tmov    %rdi,%rbx\t\t\t\t;%rbx=%rdi  40106a:\t64 48 8b 04 25 28 00 \tmov    %fs:0x28,%rax\t\t\t;这个不用管  401071:\t00 00  401073:\t48 89 44 24 18       \tmov    %rax,0x18(%rsp)\t\t\t;(%rsp+24)=rax  401078:\t31 c0                \txor    %eax,%eax\t\t\t\t;%eax=0  40107a:\te8 9c 02 00 00       \tcall   40131b &lt;string_length&gt;\t;调用函数string_length  40107f:\t83 f8 06             \tcmp    $0x6,%eax\t\t\t\t;检查字符串长度  401082:\t74 4e                \tje     4010d2 &lt;phase_5+0x70&gt;\t;如果长度为6，跳转  401084:\te8 b1 03 00 00       \tcall   40143a &lt;explode_bomb&gt;\t;否则，炸弹爆炸  401089:\teb 47                \tjmp    4010d2 &lt;phase_5+0x70&gt;  40108b:\t0f b6 0c 03          \tmovzbl (%rbx,%rax,1),%ecx\t\t;%ecx=%rbx+%rax*1  40108f:\t88 0c 24             \tmov    %cl,(%rsp)  401092:\t48 8b 14 24          \tmov    (%rsp),%rdx  401096:\t83 e2 0f             \tand    $0xf,%edx  401099:\t0f b6 92 b0 24 40 00 \tmovzbl 0x4024b0(%rdx),%edx  4010a0:\t88 54 04 10          \tmov    %dl,0x10(%rsp,%rax,1)  4010a4:\t48 83 c0 01          \tadd    $0x1,%rax  4010a8:\t48 83 f8 06          \tcmp    $0x6,%rax  4010ac:\t75 dd                \tjne    40108b &lt;phase_5+0x29&gt;  4010ae:\tc6 44 24 16 00       \tmovb   $0x0,0x16(%rsp)  4010b3:\tbe 5e 24 40 00       \tmov    $0x40245e,%esi  4010b8:\t48 8d 7c 24 10       \tlea    0x10(%rsp),%rdi  4010bd:\te8 76 02 00 00       \tcall   401338 &lt;strings_not_equal&gt;  4010c2:\t85 c0                \ttest   %eax,%eax  4010c4:\t74 13                \tje     4010d9 &lt;phase_5+0x77&gt;  4010c6:\te8 6f 03 00 00       \tcall   40143a &lt;explode_bomb&gt;  4010cb:\t0f 1f 44 00 00       \tnopl   0x0(%rax,%rax,1)  4010d0:\teb 07                \tjmp    4010d9 &lt;phase_5+0x77&gt;  4010d2:\tb8 00 00 00 00       \tmov    $0x0,%eax\t\t\t\t;将%eax初始化为 0  4010d7:\teb b2                \tjmp    40108b &lt;phase_5+0x29&gt;  4010d9:\t48 8b 44 24 18       \tmov    0x18(%rsp),%rax  4010de:\t64 48 33 04 25 28 00 \txor    %fs:0x28,%rax  4010e5:\t00 00  4010e7:\t74 05                \tje     4010ee &lt;phase_5+0x8c&gt;  4010e9:\te8 42 fa ff ff       \tcall   400b30 &lt;__stack_chk_fail@plt&gt;  4010ee:\t48 83 c4 20          \tadd    $0x20,%rsp  4010f2:\t5b                   \tpop    %rbx  4010f3:\tc3                   \tret\n我们从40107a这一步开始分析\n40107a:\te8 9c 02 00 00       \tcall   40131b &lt;string_length&gt;\t;调用函数string_length40107f:\t83 f8 06             \tcmp    $0x6,%eax\t\t\t\t;检查字符串长度401082:\t74 4e                \tje     4010d2 &lt;phase_5+0x70&gt;\t;如果长度为6，跳转401084:\te8 b1 03 00 00       \tcall   40143a &lt;explode_bomb&gt;\t;否则，炸弹爆炸\n这里表明我们的输入必须为 6 个字符的字符串\n继续来看跳转到的4010d2\n4010d2:\tb8 00 00 00 00       \tmov    $0x0,%eax4010d7:\teb b2                \tjmp    40108b &lt;phase_5+0x29&gt;\n这里将%eax初始化为 0，然后跳转回去\n我们回头接着看\n40108b:\t0f b6 0c 03          \tmovzbl (%rbx,%rax,1),%ecx\t\t;%ecx = input[i]，取出字符40108f:\t88 0c 24             \tmov    %cl,(%rsp)\t\t\t\t;把字符存到栈上401092:\t48 8b 14 24          \tmov    (%rsp),%rdx\t\t\t\t;又把字符读回到 %rdx401096:\t83 e2 0f             \tand    $0xf,%edx\t\t\t\t;只保留低4位401099:\t0f b6 92 b0 24 40 00 \tmovzbl 0x4024b0(%rdx),%edx\t\t;查表4010a0:\t88 54 04 10          \tmov    %dl,0x10(%rsp,%rax,1)\t;把查到的字符存入这个位置4010a4:\t48 83 c0 01          \tadd    $0x1,%rax\t\t\t\t;i++4010a8:\t48 83 f8 06          \tcmp    $0x6,%rax\t\t\t\t;i&lt;6?4010ac:\t75 dd                \tjne    40108b &lt;phase_5+0x29&gt;\t;继续循环4010ae:\tc6 44 24 16 00       \tmovb   $0x0,0x16(%rsp)\t\t\t;添加字符串结束符 \\0\n\nmovzbl (%rbx,%rax,1),%ecx，%ecx = %rbx + %rax * 1，%rbx 中存的是我们的输入字符串，%rax 在这里作为一个索引，初始为 0，这里的意思是取出input[i]，i 是索引\nand    $0xf,%edx，0xf是二进制数00001111，这一步只保留了字符的低四位，意味着结果是一个 0 到 15 之间的数字\nmovzbl 0x4024b0(%rdx),%edx，%edx = 0x4024b0 + %rbx，这一步相当于取 0x4024b0 这个数组上的第%rbx 个索引的值，我们这里输入命令x/s 0x4024b0，可以发现输出为maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?\n\n我们用 c 语言来描述就是\nchar *table = (char *)0x4024b0; // 这是一个长度为16的字符数组char output[7];for (int i = 0; i &lt; 6; i++) &#123;    int index = input[i] &amp; 0xF; // 取低4位    output[i] = table[index];   // 查表替换&#125;output[6] = &#x27;\\0&#x27;;\n我们继续向下看\n4010b3:\tbe 5e 24 40 00       \tmov    $0x40245e,%esi\t\t\t\t;参数2，一个内存地址4010b8:\t48 8d 7c 24 10       \tlea    0x10(%rsp),%rdi\t\t\t\t;参数1，我们之前生成的字符串output4010bd:\te8 76 02 00 00       \tcall   401338 &lt;strings_not_equal&gt;\t;比较我output和这个内存地址中的值4010c2:\t85 c0                \ttest   %eax,%eax4010c4:\t74 13                \tje     4010d9 &lt;phase_5+0x77&gt;\t\t;如果相等，过关4010c6:\te8 6f 03 00 00       \tcall   40143a &lt;explode_bomb&gt;\t\t;否则，爆炸\n我们输入x/s 0x40245e，可以看到终端的输出是flyers\n综合上述分析，我们推断，*output = &quot;flyers&quot;，我们接下来来推断input\n首先建立 Table表的字符和下标的映射关系\n\n\n\n下标 (Hex)\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10(a)\n11(b)\n12©\n13(d)\n14(e)\n15(f)\n\n\n\n\n字符\nm\na\nd\nu\ni\ne\nr\ns\nn\nf\no\nt\nv\nb\ny\nl\n\n\n\n\nf -&gt; 在 Table 中对应下标 9\nl -&gt; 在 Table 中对应下标 15 (0xF)\ny -&gt; 在 Table 中对应下标 14 (0xE)\ne -&gt; 在 Table 中对应下标 5\nr -&gt; 在 Table 中对应下标 6\ns -&gt; 在 Table 中对应下标 7\n\n所以我们输入的 6 个字符，它们的低 4 位依次是：9、15、14、5、6、7\n我们知道 ASCLL 码都是 8 比特，为了方便，我们转换成十六进制数就是：0x9、0xf、0xe、0x5、0x6、0x7\n对于高 4 位，我们不妨填入 0x6，这里不唯一\n那么答案就是，ionefg\nphase_6\n00000000004010f4 &lt;phase_6&gt;:  4010f4:\t41 56                \tpush   %r14  4010f6:\t41 55                \tpush   %r13  4010f8:\t41 54                \tpush   %r12  4010fa:\t55                   \tpush   %rbp  4010fb:\t53                   \tpush   %rbx  4010fc:\t48 83 ec 50          \tsub    $0x50,%rsp  401100:\t49 89 e5             \tmov    %rsp,%r13\t\t\t\t\t;%r13指向栈顶指针%rsp  401103:\t48 89 e6             \tmov    %rsp,%rsi  401106:\te8 51 03 00 00       \tcall   40145c &lt;read_six_numbers&gt;\t;读取6个数字  40110b:\t49 89 e6             \tmov    %rsp,%r14  40110e:\t41 bc 00 00 00 00    \tmov    $0x0,%r12d  401114:\t4c 89 ed             \tmov    %r13,%rbp  401117:\t41 8b 45 00          \tmov    0x0(%r13),%eax  40111b:\t83 e8 01             \tsub    $0x1,%eax  40111e:\t83 f8 05             \tcmp    $0x5,%eax  401121:\t76 05                \tjbe    401128 &lt;phase_6+0x34&gt;  401123:\te8 12 03 00 00       \tcall   40143a &lt;explode_bomb&gt;  401128:\t41 83 c4 01          \tadd    $0x1,%r12d  40112c:\t41 83 fc 06          \tcmp    $0x6,%r12d  401130:\t74 21                \tje     401153 &lt;phase_6+0x5f&gt;  401132:\t44 89 e3             \tmov    %r12d,%ebx  401135:\t48 63 c3             \tmovslq %ebx,%rax  401138:\t8b 04 84             \tmov    (%rsp,%rax,4),%eax  40113b:\t39 45 00             \tcmp    %eax,0x0(%rbp)  40113e:\t75 05                \tjne    401145 &lt;phase_6+0x51&gt;  401140:\te8 f5 02 00 00       \tcall   40143a &lt;explode_bomb&gt;  401145:\t83 c3 01             \tadd    $0x1,%ebx  401148:\t83 fb 05             \tcmp    $0x5,%ebx  40114b:\t7e e8                \tjle    401135 &lt;phase_6+0x41&gt;  40114d:\t49 83 c5 04          \tadd    $0x4,%r13  401151:\teb c1                \tjmp    401114 &lt;phase_6+0x20&gt;  401153:\t48 8d 74 24 18       \tlea    0x18(%rsp),%rsi  401158:\t4c 89 f0             \tmov    %r14,%rax  40115b:\tb9 07 00 00 00       \tmov    $0x7,%ecx  401160:\t89 ca                \tmov    %ecx,%edx  401162:\t2b 10                \tsub    (%rax),%edx  401164:\t89 10                \tmov    %edx,(%rax)  401166:\t48 83 c0 04          \tadd    $0x4,%rax  40116a:\t48 39 f0             \tcmp    %rsi,%rax  40116d:\t75 f1                \tjne    401160 &lt;phase_6+0x6c&gt;  40116f:\tbe 00 00 00 00       \tmov    $0x0,%esi  401174:\teb 21                \tjmp    401197 &lt;phase_6+0xa3&gt;  401176:\t48 8b 52 08          \tmov    0x8(%rdx),%rdx  40117a:\t83 c0 01             \tadd    $0x1,%eax  40117d:\t39 c8                \tcmp    %ecx,%eax  40117f:\t75 f5                \tjne    401176 &lt;phase_6+0x82&gt;  401181:\teb 05                \tjmp    401188 &lt;phase_6+0x94&gt;  401183:\tba d0 32 60 00       \tmov    $0x6032d0,%edx  401188:\t48 89 54 74 20       \tmov    %rdx,0x20(%rsp,%rsi,2)  40118d:\t48 83 c6 04          \tadd    $0x4,%rsi  401191:\t48 83 fe 18          \tcmp    $0x18,%rsi  401195:\t74 14                \tje     4011ab &lt;phase_6+0xb7&gt;  401197:\t8b 0c 34             \tmov    (%rsp,%rsi,1),%ecx  40119a:\t83 f9 01             \tcmp    $0x1,%ecx  40119d:\t7e e4                \tjle    401183 &lt;phase_6+0x8f&gt;  40119f:\tb8 01 00 00 00       \tmov    $0x1,%eax  4011a4:\tba d0 32 60 00       \tmov    $0x6032d0,%edx  4011a9:\teb cb                \tjmp    401176 &lt;phase_6+0x82&gt;  4011ab:\t48 8b 5c 24 20       \tmov    0x20(%rsp),%rbx  4011b0:\t48 8d 44 24 28       \tlea    0x28(%rsp),%rax  4011b5:\t48 8d 74 24 50       \tlea    0x50(%rsp),%rsi  4011ba:\t48 89 d9             \tmov    %rbx,%rcx  4011bd:\t48 8b 10             \tmov    (%rax),%rdx  4011c0:\t48 89 51 08          \tmov    %rdx,0x8(%rcx)  4011c4:\t48 83 c0 08          \tadd    $0x8,%rax  4011c8:\t48 39 f0             \tcmp    %rsi,%rax  4011cb:\t74 05                \tje     4011d2 &lt;phase_6+0xde&gt;  4011cd:\t48 89 d1             \tmov    %rdx,%rcx  4011d0:\teb eb                \tjmp    4011bd &lt;phase_6+0xc9&gt;  4011d2:\t48 c7 42 08 00 00 00 \tmovq   $0x0,0x8(%rdx)  4011d9:\t00  4011da:\tbd 05 00 00 00       \tmov    $0x5,%ebp  4011df:\t48 8b 43 08          \tmov    0x8(%rbx),%rax  4011e3:\t8b 00                \tmov    (%rax),%eax  4011e5:\t39 03                \tcmp    %eax,(%rbx)  4011e7:\t7d 05                \tjge    4011ee &lt;phase_6+0xfa&gt;  4011e9:\te8 4c 02 00 00       \tcall   40143a &lt;explode_bomb&gt;  4011ee:\t48 8b 5b 08          \tmov    0x8(%rbx),%rbx  4011f2:\t83 ed 01             \tsub    $0x1,%ebp  4011f5:\t75 e8                \tjne    4011df &lt;phase_6+0xeb&gt;  4011f7:\t48 83 c4 50          \tadd    $0x50,%rsp  4011fb:\t5b                   \tpop    %rbx  4011fc:\t5d                   \tpop    %rbp  4011fd:\t41 5c                \tpop    %r12  4011ff:\t41 5d                \tpop    %r13  401201:\t41 5e                \tpop    %r14  401203:\tc3                   \tret\nphase_6 的代码非常长，我们一步步来分析\n第一步：读取并检查输入\n401106:\tcall   40145c &lt;read_six_numbers&gt; ; 读取 6 个数字\n\nread_six_numbers函数我们之前在 phase_2 见过了，这个函数读取我们输入的 6 个整数并分配到栈上，此时，栈顶指针%rsp指向数组开头input[0]的地址\n\n接下来的 40110b 到 401151 这段代码是一个双重循环：\n40111b:\tsub    $0x1,%eax            ; input[i] - 140111e:\tcmp    $0x5,%eax            ; 必须 &lt;= 5401121:\tjbe    ...                  ; 否则炸\n\n条件 1：每个数字必须在 1 到 6 之间。\n\n40113b:\tcmp    %eax,0x0(%rbp)       ; 比较 input[i] 和 input[j]40113e:\tjne    ...                  ; 如果相等，炸\n\n条件 2：这 6 个数字必须 互不相同。\n结论：输入的 6 个数是 1 到 6 的全排列 (比如 3 2 1 6 5 4)。\n\n\n第二步：数值反转\n这段代码很关键：\n401153:\tlea    0x18(%rsp),%rsi      ; 数组结尾...401160:\tmov    %ecx,%edx            ; %ecx = 7401162:\tsub    (%rax),%edx          ; %edx = 7 - input[i]401164:\tmov    %edx,(%rax)          ; input[i] = 7 - input[i]\n\n作用：把每个输入的数字 x 变成 7 - x。\n\n如果你输入 1，它变成 6。\n如果你输入 6，它变成 1。\n\n\n\n\n第三步：链表重组\n这就是本关的核心。\n401183:\tmov    $0x6032d0,%edx       ; 【关键】链表头地址 Node 1\n这段代码（401176 到 4011ab）的作用是：\n\n内存里有 6 个节点（Node），每个节点存了一个值和下一个节点的指针。\n程序根据你输入的数字（变换后的 7-x），把这 6 个节点按照你指定的顺序，重新排队。\n比如你的输入对应的是 3 1 ...，那么现在的链表顺序就变成了 Node 3 -&gt; Node 1 -&gt; ...。\n\n我们先不去深究这里的指针操作，直接看最后的检查条件。\n\n第四步：链表排序检查\n程序最后会遍历这个重新排好序的链表：\n4011df:\tmov    0x8(%rbx),%rax       ; %rax = 当前节点的下一个节点 (Next Node)4011e3:\tmov    (%rax),%eax          ; 取出 下一个节点的值 (Value)4011e5:\tcmp    %eax,(%rbx)          ; 比较 当前节点的值 vs 下一个节点的值4011e7:\tjge    4011ee               ; 如果 Current &gt;= Next，继续4011e9:\tcall   &lt;explode_bomb&gt;       ; 否则炸！\n\n条件：Current_Value &gt;= Next_Value\n结论：重组后的链表，节点里的值必须是 从大到小 排序的！\n\n\n破解行动\n我们不需要手动去推指针，我们只需要知道：\n\n这 6 个节点里存的值分别是多少？\n哪个节点的值最大，哪个最小？\n按从大到小的顺序，它们原本的索引（编号）是多少？\n\n1. 探查链表数据\n在 GDB 中，我们看到链表头是 0x6032d0。\n链表节点的结构通常是：\n\nOffset 0: Value (4 字节)\nOffset 8: Next Pointer (8 字节)\n\n我们来查看这 6 个节点：\nNode 1 (0x6032d0):\nx/d 0x6032d0        -&gt; 查看值x/gx 0x6032d0+8     -&gt; 查看下一个节点的地址\n\nNode 1: Value = 332 (0x14c)\nNode 2: Value = 168 (0xa8)\nNode 3: Value = 924 (0x39c)\nNode 4: Value = 691 (0x2b3)\nNode 5: Value = 477 (0x1dd)\nNode 6: Value = 443 (0x1bb)\n\n2. 排序\n我们把刚才找到的值按 从大到小 排序：\n\nNode 3: 924\nNode 4: 691\nNode 5: 477\nNode 6: 443\nNode 1: 332\nNode 2: 168\n\n对应的节点编号顺序是：3, 4, 5, 6, 1, 2\n3. 反转陷阱\n还记得第二步里的 7 - x 吗？\n程序是按 7 - input 来重排链表的。\n所以：\n7 - input[0] = 3 =&gt; input[0] = 4\n7 - input[1] = 4 =&gt; input[1] = 3\n7 - input[2] = 5 =&gt; input[2] = 2\n7 - input[3] = 6 =&gt; input[3] = 1\n7 - input[4] = 1 =&gt; input[4] = 6\n7 - input[5] = 2 =&gt; input[5] = 5\n最终答案： 4 3 2 1 6 5\n","categories":["学习笔记","计组"],"tags":["学习笔记","汇编","计组"]},{"title":"《水流云在：我的西南联大岁月》阅读笔记","url":"/post/2bb93c7b.html","content":"《水流云在：我的西南联大岁月》阅读笔记\n本书是汪曾祺的散文集，以人民文学出版社《汪曾祺全集》散文卷为底本，主要以对大学青春岁月的回忆为主体。2025 年上半年购于广州购书中心天河店，具体日期记不太清了。\n师恩母爱 ——怀念王文英老师\n在读到 “师恩母爱 ——怀念王文英老师” 这一章的这一段时，颇为感动， 泪难自禁。\n\n1981 年秋，我应邀回阔别多年的家乡讲学，带了一点北京的果脯去看王先生和张先生，并给他们各送了一首在招待所急就的诗。给王先生的一首不文不白，毫无雕饰。第二天张先生带了两瓶酒到招待所来看我，我说哪有老师来看学生的道理，还带了酒！张先生说，是王先生一定要他送来的。说王先生看了我的诗，哭了一晚上。这首诗全诗是：\n小孩子乖乖，把门儿开开，歌声犹在，耳边徘徊。我今亦老矣，白髭盈腮，念一生美育，从此培栽，师恩母爱，岂能忘怀！愿吾师康健，长寿无灾。\n张先生说，王先生对他说：“我教那么多学生，长大了，还没有一个来看过我的！”王先生指着收“师恩母爱，岂能忘怀”对张先生收：“他进幼稚园的时候还戴着他妈妈的孝！”我这才知道王先生为什么对我特别关心，特别喜爱。张先生反复念了这两句，连说：“师恩母爱！师恩母爱！”\n\n“我今亦老矣，白髭盈腮，念一生美育，从此培栽，师恩母爱，岂能忘怀！”\n觅我游踪五十年\n\n将去云南，临行前的晚上，写了三首旧体诗。怕到了那里，有朋友叫写字，临时想不出合适词句。一九八七年去云南，一路写了不少字，平地抠饼，现想词儿，深以为苦。其中一首是：\n羁旅天南久未还，故乡无此好湖山。长堤柳色浓如许，觅我游踪五十年。\n\n","categories":["阅读笔记","《水流云在：我的西南联大岁月》"],"tags":["阅读","汪曾祺"]},{"title":"《利玛窦的记忆宫殿》阅读笔记","url":"/post/a4723547.html","content":"《利玛窦的记忆宫殿》阅读笔记\n1\n一直以来就对利玛窦其人很感兴趣，很多人似乎有种固有的认知，即中国与西方之间是相互隔绝。然而，若仔细翻阅历史，便会发现中西之间的交流远比我们以为的早和深。\n阅读本书，不像是在读一本史学著作，而像是读一本小说。史景迁的写作手法就如同讲故事般，以独特的视角带读者同历史人物一道一同体会真实的历史事件。\n作者以神奇的记忆术为引线，以利玛窦记忆宫殿中的四个形象：两名相互搏斗的武士，一名来自西域的女子，执镰刀的农夫，怀抱圣婴的圣母，和利玛窦交给程大约在《程氏墨苑》中刊刻的四幅图画为章节，带读者走入利玛窦的精神世界，了解他的生平。\n所谓记忆术，即在脑海中建构一座记忆宫殿，在其中为希望记住的东西给予一个形象，再为其分配一个适当的位置。利玛窦曾用汉语写过一本《西国记法》，希望借记忆术的功效吸引渴望考取功名的士子们，从而推进传教事业。虽然利玛窦本人多次在中国人面前展示他惊人的记忆力，然而似乎并没有人能练成这神奇的记忆术。\n利玛窦于 1582 年 8 月 7 日抵达澳门，先是在澳门努力学习中文。他脱下洋装，换上汉服，同时学习两种近代汉语——近代南京官话和近代粤语广府话，阅读大量中文书籍。而后辗转广州，肇庆，韶州，南昌，南京，北京，最终在 1610 年 5 月 11 日于北京去世。\n利玛窦在中国的生活和传教事业历经波折，经历过普通民众的围观，嘲弄，甚至冲突，为此扭伤了他的脚踝，在他剩下的十八年生命里，一旦要走远路，便伤痛缠身，只能跛脚前行；遗失圣书经文的痛苦；挚友与同事的死亡。\n\n利玛窦告诉弟弟奥拉吉奥，中国人总是对他的满头白发表示惊异，并奇怪为什么他年纪不大却看起来如此苍老。他补充说：“他们正是我白发苍苍的原因。”在 1595 年 8 月写给他的澳门上司——葡萄牙人孟三德神父的信中，利玛窦说，上帝选中了他，赐予他十二年含辛茹苦、饱受屈辱的生活。\n\n利玛窦不仅是一位虔诚的耶稣会士，在自然科学领域也涉猎颇深，撰写《乾坤体义》，介绍托勒密和亚里士多德的学说，绘制世界地图《坤舆万国全图》，和徐光启等人翻译欧几里得《几何原本》。\n2\n读这本书的时候，时常会有一种心灵的震撼，一个人漂洋过海，来到异国他乡，一片完全未知，语言文化不通的领域，凭着理想和信念想要融入这个社会。为此他学习汉语，穿着汉服，留起长发，打扮的像一个中国儒生，历经无数肉体和精神的折磨，依旧不夺其志，这是一种怎样强大的精神意志啊。\n\n1583年，利玛窦知道，在中国文化之外继续旁观已经变得十分奢侈。他剃掉须发，穿上袈裟，化身中国僧侣；此后十年间，他又蓄起胡子，穿上儒衫，打入热衷科举的士大夫群体。他始终认为，要开启文化上的交流，就应该“做中国人中间的中国人”。然而，无论如何努力，他想要面见的万历皇帝却始终拒绝见他。\n在人生的终点回望，利玛窦觉得自己茫然无着，不知身在何处，却早已难以返身。他不会知道，他的这些切身尝试，早已铺陈开十六世纪之后数百年中西文明交汇的壮阔图景。\n或许一切事情在肇始之初，都渺小微弱，无论事中人还是旁观者都无法说服自己，它将来能成就如此宏大的局面。\n\n3\n觉得这两章写得很好，摘抄上来以做纪念。\n第九章 宫门之内\n利玛窦脚穿绣花鞋，站在记忆宫殿的门口，许久以前，他从窗口跳出来，伤了一只脚，如今还隐隐作痛。\n他的思绪飘荡，跨越时空。眼前展现的是微微闪光的宫墙和立柱，是廊檐和雕饰精美的大门，在那后边，储放着许多记忆形象，那一切都来自阅读、经历，还有他那坚定的信仰。\n他看到一个人，那是大太监马堂，马堂暴怒异常，手中紧握着木刻的十字架，基督被钉在那十字架之上，汩汩淌血；他听见风声呼啸，那是赣江之上，狂风肆虐，前船的人们大喊示警，可惜船只倾覆，他和若望·巴达拉斯都掉入水中；他闻到焚香气味，那是在句容那漂亮的大花园里，他将一幅三联圣像画放在庙里的神龛上，周围点起香来，心中默祷；他品尝家常饭菜，那是肇庆城外的乡间，贫苦的农夫们拿来招待他的；他感到了面贴面的温情，那是临终前的石方西神父，双臂紧紧围抱住他的脖颈，两人泪流满面。\n在这片未知的地域，利玛窦已经走得太远，远超他的预料。他有时茫然无着，不知自己是否应该返回，自己是否还能返回。一次他写信给少年时的学友弗利加蒂，引用了维吉尔的诗句，“下往地狱的道路易行，但仍得返身原路踏上天国”。这句诗出自《埃涅阿斯纪》的第六卷，利玛窦和弗利加蒂多年前一道学习这诗篇，童年时他反复吟诵。但那一刻他匆忙间，只凭记忆引述，缩减了原文：\n\n    下往地狱的道路易行，\n  \t黑暗冥府的大门昼夜敞开。\n    但要返身原路登上天国，\n    其路险阻，多费辛劳。\n\n当时埃涅阿斯请求下入冥界，去寻找他死去的父亲，而女先知库迈的西比尔就这样劝告他。\n在利玛窦的画中，诸色人物都品味着命运的尖厉：使徒彼得在波涛中挣扎，两位门徒在前往以马忤斯途中停步，而所多玛的人们则跌倒在地，眼盲不能视物。在记忆宫殿的会客大厅，几个形象各安其位，两名在搏斗的武士，“回回”妇女，还有代表着姓氏“利”的农夫。\n“这样的事很常见，”利玛窦写道，“生活在后世的人们，往往无法了解前时代的伟大事业或行动如何起源。我时常揣思，这是缘于何故，发现只能如此解释：一切事情（包括那些最后取得极大成功的）在肇始之初，是那样微弱渺小，人们自己都无法说服自己相信，它将在将来成就如此宏大之局面。”\n他立在门口，身躯高大，留浓重的胡须，身着紫色镶蓝边的丝质长袍。记忆宫殿内寂静无声。在他身后有两名妇女，每位怀中都抱着一个婴孩。其中一位身着华美无比的绣花长裙，头肩部披着一块飘动的头巾，手持着一枝玫瑰。另一位丫鬟打扮，衣装朴素，头梳左右两个发髻，既示以年幼，又表面其仆女的身份。\n“尽管我还年轻，”利玛窦有次写信给马菲伊——他的友人，研究基督宗教扩张编年史的学者——说道，“我已经有了一些老年人的习性，总是喜欢称颂过去的时光。”\n两个婴孩也看着他。一个举起小小的右手，对天祈祷；另一个张开双臂，像在玩耍。四周很平静，但远处传来低沉的杂音，那是北京城街市的喧嚣。\n他关上了那扇门。\n译后记\n翻译史景迁先生的《利玛窦的记忆宫殿》，本身就是一次旅行。四百多年前利玛窦梯航远来，踏上东方土地，十几年间行旅中华万里河山。如今译者坐于灯下，但意念穿梭时空，温暖的山城马切拉塔、狂风肆虐的印度洋、南国旖旎、北海冰封，一幕幕闪现，这都有赖于史景迁先生笔下的魔力。作者以“记忆术”为引线，牵出的是一整幅十六、十七世纪东西方交流的宏阔图景。精彩的历史叙述，已能模糊“真实”与“想象”的界线，加之利玛窦记忆术本身具有的神奇色彩，使这部著作愈发显得亦真亦幻、动人心魄。\n几个世纪回转，当年种种，言辞交锋、挣扎与痛苦，仿佛都已散入历史的烟尘，但记忆本身——即使不凭借记忆术——却不会轻易泯灭。不分东海西海，人类对于恒久记忆的兴趣，几百年来并没有改变多少。若干年前，香港无线电视台（TVB）开播电视剧《读心神探》，出现在剧中桌头的一本《记忆宫殿》，又激起许多观众对西方记忆秘术的追捧。此中热闹，无论是利玛窦神父，还是史景迁先生，恐怕都无法料想。\n","categories":["阅读笔记","《利玛窦的记忆宫殿》"],"tags":["阅读"]},{"title":"EU5初体验","url":"/post/4339b790.html","content":"时隔 12 年，欧陆风云系列即将推出第五部作品，作为 P 社的最具雄心的历史战略模拟游戏，也是 P 社的当家花旦，那必须第一时间预购啊 😍\n北京时间 2025 年 11 月 5 号 1 点，必须第一时间尝尝咸淡 🤗\n\n20 小时游玩体验后，鉴定为纯纯一坨半成品，垃圾优化，瞎眼 UI，卡得要死，美术极其垃圾。\n这一作内容非常繁杂，游戏机制从底层上缝合了维多利亚 3 的经济系统和人群模拟。同时细化了大量地块，添加了3D地形。\n但垃圾的UI设计、美术以及性能优化使得你很难流畅愉快地体验这一切。\n将时间流逝单位从天换成小时很难说是成功还是败笔，更细的颗粒度使得游戏对各项数据的模拟将更为细致和真实，但极大程度拖慢了游戏速度，造成卡顿。本人笔记本电脑配置为 Intel Ultra 5 125H + 4060 + 32G，自认为算是中等偏上配置了，中等画质下，开始一段时间后还好，有六七十帧，但玩了两三个小时后帧率只有二三十帧了。15 个小时后也只玩到了 1500年，很难想象从 1337 年文艺复兴时代到 1837 年大革命时代，完整体验一把五百年历史的游戏需要多久时间。\n从底层机制上可以看出 P 社面向未来十年大战略模拟游戏的雄心壮志，但单调和稀少的风味事件也透露出大量 DLC 可以推出的余地，真是 P 社祖传艺能了。\n","categories":["游戏","欧陆风云5"],"tags":["游戏","Paradox","EU5"]},{"title":"为WSL设置代理","url":"/post/6558428b.html","content":"为 WSL2 设置代理\nWSL 有两个配置文件：\n\n.wslconfig：适用于所有 WSL 的配置\nwsl.conf：在/etc目录下，仅适用于对应的特定 Linux 发行版\n\n.wslconfig文件在~/目录下，即C:\\Users\\&lt;UserName&gt;\\.wslconfig\n但是.wslconfig文件默认并不存在，需要手动创建。\n在正确的目录下创建文件，示例如下\n[wsl2]# 开启自动代理autoProxy=true# 开启 DNS 隧道dnsTunneling=true# 开启镜像网络模式networkingMode=mirrored# 同步防火墙规则firewall=true[experimental]# 自动回收内存autoMemoryReclaim=gradual# 自动释放硬盘空间sparseVhd=true\n要使 WSL 使用 Windows 的代理，需要设置autoProxy=true，强制 WSL 使用 Windows 的 HTTP 代理信息。\n参考资料：\n","categories":["技术分享"],"tags":["Linux","技术分享"]},{"title":"十月二十二日夜","url":"/post/c453eba7.html","content":"十月二十二日夜\n广州最近降温了，晚上总是寒风凛冽，吹得瑟缩起身体。寒意却总能激起我的思绪飞扬。\n大学不比中学，不求评优保研的话，没有那般大的课业和考试的压力，总有许多可自由支配的时间，做些自己想做的事，读些自己想读的书，写些自己想写的东西。闲下来也可以边听音乐边呆坐着做些不着边际的思考。没有名利物欲的追求，不必担惊受怕，平静的生活惬意得使人想永久沉溺于此。然而，人总要在社会上谋得一职位，若干年后，也终有毕业的一天，也终有工作的一日。那时的我又将怎样呢？我的志向在何方呢？不知道过去的我是否曾想到现在的我呢？\n人死后会有来世吗？意识会归于一片混沌还是又将出现呢？\n一想到此，我便不禁感慨人生的短暂，人类的渺小，宇宙的旷达，我所做的一切又有什么意义呢？\n我的躯体所能抵达的地方有限，然而我的思想却能横跨五大洲七大洋，越过地球，触摸宇宙的边界，追溯千年以前，想象千年以后。\n","categories":["杂谈"],"tags":["杂谈"]},{"title":"维护日志","url":"/post/ffcd24f1.html","content":"维护日志\n2025-10-13\n使用 hexo 和 butterfly 主题搭建了一个简单的静态个人博客，部署在 github pages，目前没有什么内容，希望以后能够坚持记录。\n2025-10-14\n稍微修改了一些设置，本来想将图片托管在图床上的，尝试使用 github+picgo，但效果不太行，尝试了下 cloudfare r2，等以后图片多起来了再试试吧。\n2025-10-15\n\n\n使用 cloudflare r2 + picgo 终于把图床搞好了，用的是picgo-plugin-cloudflare-r2这个插件，感谢作者！\n\n\n修改了一些 css 样式。在页脚底部添加了计时器。\n\n\n在 Vercel 和 MongoDB Atlas 上部署了 Twikoo 评论系统，具体教程在Twikoo 官方文档上写得很详细了，还可以参考以下两篇博客。\n\n\n【Vercel】Twikoo | 为你的 HEXO 加入评论系统\n\n\nHEXO 系列教程 | 在 Butterfly 主题中使用评论系统 twikoo\n\n\n\n\n2025-10-16\n\n在阿里云上 14 块钱买了一个一年的域名，添加了 Cloudflare DNS。\n在测试的时候发现国内访问太慢了，将网站从 github pages 迁移到了 netlify。结果突然发现 netlify 免费用户每月只有 300 积分，而每一次构建都要 15 积分……，最后还是迁移回 github pages。\n\n2025-10-17\n\n更换 CDN 为 jsdmirror，发现有些资源没有，换回了 jsdeliver。\n在 Vercel 上绑定了自己的域名，加快国内访问速度，具体可以参见这篇博客解决 Vercel 被墙导致 Twikoo 无法评论的问题：在 Vercel 添加子域名。\n\n2025-10-18\n\n添加了星空背景特效\n\n2025-10-19\n\n添加了萌 IPC 备案\n添加了 wizard 加载动画和 gulp 优化，具体可参见这篇博客hexo 博客 butterfly 主题安装及魔改笔记。\n\n2025-11-7\n\n添加了谷歌和必应搜索引擎收录，详见本站这篇博客个人博客搜索引擎收录\n\n","categories":["维护日志"],"tags":["本站相关","日志"]},{"title":"计算机网络——应用层","url":"/post/e1113bf9.html","content":"计算机网络——应用层\n应用层体系结构\n客户-服务器模型(C/S)\n服务器：提供计算服务的设备。\n1、永久提供服务。\n2、永久性访问地址/域名。\n客户机：请求计算服务的主机。\n1、与服务器通信，使用服务器提供的服务。\n2、间歇性接入网络。\n3、可能使用动态 IP 地址。\n4、不与其他客户机直接通信。\nP2P(Peer-to-Peer)模型\n不存在永远在线的服务器\n每个主机既可以提供服务，也可以请求服务。\n任意端系统/结点之间可以直接通讯。\n结点间歇性接入网络。\n结点可能改变 IP 地址。\n可拓展性好，网络健壮性强。\nHTTP 协议\nHTTP 协议是一种应用层协议，它规定了参与 Web 通信的浏览器和 Web 服务器之间的通信细节。HTTP 协议主要用于传输超文本网页及其相关网络资源。HTTP 使用 TCP 作为运输协议。\nHTTP 报文格式\n请求报文\n下面是一个典型的 HTTP 请求报文\nGET /index.html HTTP/1.1Host: www.example.comUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)Accept: text/htmlConnection: keep-alive\n请求行\n报文的第一行是请求行，也是最核心的一行，由三个字段组成，由空格分开。\n\n方法字段：表明希望服务器要执行的操作，包括 GET、POST、PUT、DELETE、HEAD。\nURL 字段：指定请求资源的路径，只包含路径部分，不包括域名。\nHTTP 版本字段：表示使用的 HTTP 协议版本。\n\n首部行\n首部行由若干个键值对组成，用来传递附加信息，比如客户端的类型、期望接收的数据格式等。\n\nHost: 必须包含的字段 (在 HTTP/1.1 中)。它指明了请求的目标服务器域名。为什么需要它？因为一台物理服务器上可能托管着多个网站（虚拟主机），服务器需要通过Host字段来判断你到底想访问哪个网站。\n\nHost: www.example.com\n\n\nUser-Agent: “用户代理”，也就是你客户端的身份标识。它告诉服务器你用的是什么浏览器、什么操作系统。服务器可以根据这个信息返回对特定浏览器优化过的内容。\n\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36\n\n\nAccept: 告诉服务器，我的浏览器能理解哪些类型的内容。\n\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 (表示优先接收 HTML，但其他也行)\n\n\nAccept-Language: 告诉服务器，我偏好哪种语言。\n\nAccept-Language: zh-CN,zh;q=0.9 (首选简体中文)\n\n\nConnection: 控制 TCP 连接的行为。keep-alive表示希望使用我们之前讨论过的持续连接。\n\nConnection: keep-alive\n\n\n\n实体主体\n可选的，它包含了你想要提交给服务器的数据。\n对于 GET 请求，由于它的目的是从服务器获取数据，所以通常没有实体主体。\n响应报文\nHTTP/1.1 200 OKDate: Wed, 18 Apr 2024 12:00:00 GMTServer: Apache/2.4.1 (Unix)Last-Modified: Wed, 18 Apr 2024 11:00:00 GMTContent-Length: 12345Content-Type: text/html; charset=UTF-8\n状态行\n这是响应报文的第一行，包含了最重要的处理结果信息。\n\n版本 : 服务器使用的 HTTP 协议版本，如 HTTP/1.1。\n状态码: 一个三位数的数字，是响应的核心。它用代码的形式告诉客户端请求的结果是成功、失败还是需要其他操作。\n原因短语 : 对状态码的一个简短的、人类可读的文字描述，如 OK, Not Found。\n\n状态码被分成了五大类：\n\n2xx (成功): 表示请求被成功接收、理解和处理。\n\n200 OK: 最常见的成功状态码。表示请求成功，服务器已返回所请求的数据。\n\n\n3xx (重定向): 表示需要客户端采取进一步的操作才能完成请求。\n\n301 Moved Permanently: 永久重定向。你请求的资源已经永久搬到了一个新的 URL。浏览器会自动跳转到新地址。\n302 Found: 临时重定向。\n\n\n4xx (客户端错误): 表示客户端的请求有语法错误或请求无法实现。\n\n400 Bad Request: 请求本身有误，服务器无法理解。\n403 Forbidden: 服务器理解请求，但拒绝执行。你没有权限访问。\n404 Not Found: 最著名的状态码。服务器上没有找到你请求的资源（网页、图片等）。\n\n\n5xx (服务器错误): 表示服务器在处理请求的过程中发生了内部错误。\n\n500 Internal Server Error: 服务器内部出错了，这是一个通用的服务器错误码。\n503 Service Unavailable: 服务器当前暂时无法处理请求（可能过载或正在维护）。\n\n\n\n首部行\n和请求首部一样，这里也是 键值对的列表，提供了关于响应的附加信息。\n\nContent-Type: 极其重要。告诉浏览器，我发给你的实体主体是什么格式的。浏览器根据这个值来决定如何解析和展示内容。\n\ntext/html: 这是 HTML 文档。\nimage/jpeg: 这是 JPG 图片。\napplication/json: 这是 JSON 数据。\ntext/css: 这是 CSS 样式表。\n\n\nContent-Length: 告诉浏览器，实体主体的长度是多少字节。浏览器可以用它来判断数据是否接收完整。\nDate: 服务器生成并发送此响应的日期和时间。\nServer: 告诉客户端，处理你这个请求的服务器软件是什么。\n\nServer: Apache/2.4.1 (Unix)\nServer: nginx/1.20.1\n\n\nLast-Modified: 请求的这个文件在服务器上最后一次被修改的时间。这个首部主要用于浏览器缓存。\nSet-Cookie: 非常重要。服务器通过这个首部在你的浏览器上设置一个 Cookie。下次你再请求这个网站时，浏览器会自动带上这个 Cookie，让服务器认出你。\n\n实体主体\n这就是真正的客户端请求的资源本身。\n\n如果请求的是一个 HTML 页面，实体主体就是这个页面的完整 HTML 代码。\n如果请求的是一张图片，实体主体就是这张图片的二进制数据。\n\nHTTP 响应的状态码\n状态代码由三位数字组成，第⼀个数字定义了响应的类别，共分 5 种类别：\n1xx：指示信息——表示请求已接收，继续处理；\n2xx：成功——表示请求已被成功接收、理解和接受；\n3xx：重定向——要完成请求必须进⾏更进⼀步的操作；\n4xx：客户端错误——请求有语法错误或请求⽆法实现；\n5xx：服务器端错误——服务器未能实现合法的请求。\nCookie\n是服务器发送到用户浏览器并保存在本地的一小块数据。浏览器会存储 cookie 并在下次向同一服务器再发起请求时携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器——如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。\n服务器使用响应首部字段Set-Cookie来发送 cookie 信息。\n当用户的浏览器第一次访问一个需要状态管理的网站时（比如登录），服务器在处理完你的请求后，会在发回的 HTTP 响应报文中，包含一个特殊的**Set-Cookie**首部。\nHTTP/1.1 200 OKContent-Type: text/htmlSet-Cookie: session-id=3a8d4z9b2c7f1; Expires=Wed, 21 Oct 2025 07:28:00 GMT\n当用户的浏览器收到响应报文后，它会在管理的 cookie 文件中添加收到的 cookie 信息。\n当用户再次访问这个网站时，会自动在请求报文的首部中添加一个Cookie字段\nGET /cart.html HTTP/1.1Host: www.example-store.comCookie: session-id=3a8d4z9b2c7f1\n当服务器收到含有 Cookie 首部的请求后，会去数据库中查找这个 Cookie 信息，从而恢复之前的信息，比如登录信息等。\n\nDNS\nDNS（域名系统，Domain Name System）将人类易于记忆的域名（例如 mozilla.org）翻译成为数字化的 IP 地址（例如 192.0.2.172）；这一从域名到 IP 地址的映射过程被称为 DNS 查询。与之对应，DNS 反向查询用来找到与 IP 地址对应的域名。\nUDP socket 实验\n《计算机网络：自顶向下方法》(第 8 版)一书中的一个 socket 编程实验，实验任务如下：\n\n\n客户从其键盘读取一行字符（数据）并将该数据向服务器发送\n\n\n服务器接受该数据并将这些字符转换为大写\n\n\n服务器将修改的数据发送给客户\n\n\n客户接收修改的数据并在其监视器上将该行显示出来\n\n\nUDPClinet.py\nimport socket# 服务器 IP 地址serverName = &#x27;127.0.0.1&#x27;# 服务器端口号serverPort = 12000# 创建UDP socketclientSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# 获取用户输入message = input(&#x27;Input lowercase sentence:&#x27;)# 将字符串编码为字节并发送给服务器clientSocket.sendto(message.encode(), (serverName, serverPort))# 从服务器接受返回的数据modifiedMessage, serverAddress = clientSocket.recvfrom(2048)print(modifiedMessage.decode())clientSocket.close()\nUDPServer.py\nimport socket# 服务器端口号serverPort = 12000# 这里我们不指定IP地址，而是使用空字符串，表示服务器可以在任何可用的网络接口上接收连接serverName = &#x27;&#x27;# 创建UDP socket# AF_INET 表示使用IPv4，SOCK_DGRAM 表示这是一个UDP socketserverSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# 将 socket 绑定到指定的端口serverSocket.bind((serverName, serverPort))print(&quot;The server is ready to receive&quot;)# 进入一个无限循环，持续等待并处理客户端发送的请求while True:    # recvfrom 会阻塞程序，直到收到一个数据报    # 2048 是缓冲区大小，表示一次最多能接收 2048 字节的数据    # 它返回两个值：数据本身(message)和客户端的地址(clientAddress)    message, clientAddress = serverSocket.recvfrom(2048)    # 将接收到的数据解码为字符串    decoded_message = message.decode()    # 将字符串转换为大写    modifiedMessage = decoded_message.upper()    # 将修改后的字符串编码为字节，并发送回客户端    serverSocket.sendto(modifiedMessage.encode(), clientAddress)    print(&#x27;send success&#x27;)\n\n","categories":["学习笔记","计算机网络"],"tags":["学习","计算机网络","应用层"]},{"title":"《酉阳杂俎》阅读笔记","url":"/post/d2b7ae7b.html","content":"《酉阳杂俎》阅读笔记\n之前在知乎上偶然间刷到了一篇关于酉阳杂俎的文章，觉得很是有趣，趁着去广州购书中心的机会便买了下来。本身内容繁杂，长短不一，慢慢读吧。\n作者简介\n本书作者段成式（803？——863），字柯古，祖籍临淄。段成式出身望族。其六世祖段志玄（598——642）是唐朝开国元勋，官至右卫大将军，封褒国公，为凌烟阁二十四功臣之一，陪葬昭陵。其父段文昌（773——835）为中唐名臣，穆宗时曾为中书侍郎、同中书门下平章事，文宗时进封邹平郡公，历镇淮南、荆南、剑南西川。其母则是中唐名相武元衡之女。\n段文昌于唐德宗贞元十五年（799）入剑南西川节度使韦皋幕府。段成式即出生于成都，青少年时随父侍宦，辗转于长安和成都，江东和西蜀之间。\n","categories":["阅读笔记","《酉阳杂俎》"],"tags":["阅读","古文"]},{"title":"计组——汇编学习笔记","url":"/post/3a831366.html","content":"计组——汇编学习\n本文与著名的《深入理解计算机系统》（CS:APP）一书一样，汇编代码格式采用 AT&amp;T 格式。\nAT&amp;T 格式与 Intel 格式的不同\n\n\n\n特性\nAT&amp;T 格式\nIntel 格式\n\n\n\n\n操作数顺序\nop s,d源在左，目标在右\nop d,s目标在左，源在右\n\n\n寄存器表示\nmov %ebx,%eax寄存器名称前加 %\nmov ebx,eax不带前缀\n\n\n立即数表示\nmov $985,%eax立即数前加 $\nmov 985,%eax不带前缀\n\n\n主存地址表示\n(af996h)用小括号\n[af996h]用中括号\n\n\n读写长度表示\nmovl，movqb、w、l、q 分别表示 1、2、4、8 字节\nmov byte ptr [af996h],5在主存地址前说明读写长度\n\n\n主存偏移表示\n偏移(基址, 索引, 缩放)8(%ebp)(%eax, %ebx, 4)\n[基址 + 索引 * 缩放 + 偏移][ebp + 8][eax + ebx * 4]\n\n\n注释\n#\n;\n\n\n\n内存寻址\n在 AT&amp;T 语法中，一个完整的内存地址表达式格式为：\n$$\nD(R_b, R_i, S)\n$$\n计算出的内存地址为：\n$$\n\\text{内存地址} = D + R_b + R_i \\times S\n$$\n各部分的含义：\n\n$D$（Displacement / 偏移量）：一个常数值（例如 8、-12，或标签 my_var 的地址），类似于“基础”的门牌号。\n$R_b$（Base Register / 基址寄存器）：一个寄存器（例如 %ebp、%eax、%rbx），提供“动态的”基准地址，如函数栈帧的开始或数组的开头。\n$R_i$（Index Register / 索引寄存器）：另一个寄存器（例如 %ecx、%eax），通常用于存储“索引”值，如循环变量 i。\n$S$（Scale / 缩放因子）：一个固定的乘数，值必须是 1、2、4 或 8。它配合索引（$R_i$）使用。如果 $R_i$ 存储数组下标 i，而数组元素大小为 4 字节（int），则 $S$ 应为 4，这样 Ri * S 就等于 i * 4，即第 i 个元素的字节偏移。\n\n常用汇编指令\n数据传送指令\n这类指令负责在寄存器和内存之间移动数据，是所有程序的基础。\n1. mov（Move）\n\n\n功能：将源操作数的值复制到目标操作数。这是最常用、最重要的指令。\n\n\nAT&amp;T 格式：movl source, destination\n\n\n示例：\nmovl %eax, %ebx      # 将寄存器 %eax 的值复制到 %ebxmovl $10, %eax       # 将立即数 10 存入寄存器 %eaxmovl (%ebx), %eax    # 将 %ebx 寄存器指向的内存地址中的数据加载到 %eaxmovl %eax, -4(%rbp)  # 将 %eax 的值存入栈上地址为 %rbp-4 的位置\n\n\n2. lea（Load Effective Address）\n\n\n功能：计算源操作数（必须是内存地址）的有效地址，并将其加载到目标操作数（必须是寄存器）。它传送的是地址本身，而不是地址指向的数据。\n\n\nAT&amp;T 格式：leaq source_address, destination_register\n\n\n示例：\nleaq -8(%rbp), %rax  # 将内存地址 %rbp-8 这个地址值本身加载到 %rax 寄存器                     # 这条指令执行后，%rax 的值就是 %rbp 的值减 8\n\n\n说明：lea 指令非常灵活，常被用来进行不影响标志位的快速算术运算。\n\n\n3. push / pop（Push / Pop）\n\n\n功能：在栈上压入或弹出数据。栈是“后进先出”（LIFO）的数据结构，在函数调用中至关重要。\n\n\npush：将操作数压入栈顶，栈指针 %rsp 会减小。\n\n\npop：从栈顶弹出一个数据到操作数，栈指针 %rsp 会增大。\n\n\nAT&amp;T 格式：pushq source / popq destination\n\n\n示例：\npushq %rbx           # 将 %rbx 的值压入栈顶popq %rax            # 从栈顶弹出一个值到 %rax\n\n\n算术运算指令\n用于执行基本的数学计算。\n1. add / sub（Add / Subtract）\n\n\n功能：加法和减法。\n\n\nAT&amp;T 格式：addl source, destination（结果：destination = destination + source）\n\n\n示例：\naddl %eax, %ebx      # %ebx = %ebx + %eaxsubl $5, %ecx        # %ecx = %ecx - 5\n\n\n2. inc / dec（Increment / Decrement）\n\n\n功能：将操作数加一或减一。比 add 或 sub 更高效。\n\n\nAT&amp;T 格式：incl destination\n\n\n示例：\nincl %eax            # %eax = %eax + 1decq %rbx            # %rbx = %rbx - 1\n\n\n3. imul（Signed Multiply）\n\n\n功能：有符号整数乘法。\n\n\nAT&amp;T 格式：imull source, destination（结果：destination = destination * source）\n\n\n示例：\nimull %ebx, %eax     # %eax = %eax * %ebx\n\n\n4. idiv（Signed Divide）\n\n\n功能：有符号整数除法。这个指令比较特殊。\n\n\nAT&amp;T 格式：idivl divisor\n\n\n说明：idiv 会使用 %edx:%eax（一个 64 位数）作为被除数，除数是指令的操作数。商存储在 %eax 中，余数存储在 %edx 中。\n\n\n示例：\ncqto                 # 64 位模式下，将 %rax 符号扩展到 %rdx:%raxidivq %rbx           # (%rdx:%rax) / %rbx，商在 %rax，余数在 %rdx\n\n\n注意：在执行 32 位除法 idivl 前，通常需要 cdq 指令将 %eax 符号扩展到 %edx。\n\n\n逻辑与比较指令\n1. and / or / xor (Bitwise AND / OR / XOR)\n\n\n功能: 按位进行与、或、异或运算。\n\n\nAT&amp;T 格式: andl source, destination (结果: destination = destination &amp; source)\n\n\n示例:\nandl $0xf, %eax      # 清零 %eax 的高28位，保留低4位xorl %eax, %eax      # 一种将 %eax 清零的高效方法\n\n\n2. cmp（Compare）\n\n基本含义：cmp 指令对两个操作数执行一次“隐藏”的减法操作（Destination - Source），但不保存结果，仅根据结果设置 EFLAGS 寄存器中的标志位。\n语法格式：cmp Source, Destination\n影响的标志位：\n\nZF（Zero Flag - 零标志位）：如果相减结果为 0（即两个数相等），ZF 设为 1；否则为 0。\nSF（Sign Flag - 符号标志位）：如果结果为负数，SF 设为 1；否则为 0。\nCF（Carry Flag - 进位标志位）：用于无符号数比较。如果减法产生了借位（Destination &lt; Source），CF 设为 1。\nOF（Overflow Flag - 溢出标志位）：用于有符号数比较。如果减法导致有符号溢出，OF 设为 1。\n\n\n\n3. test（Test）\n\n基本含义：test 指令对两个操作数执行“隐藏”的按位与操作（Destination &amp; Source），但不保存结果，仅根据结果设置标志位。\n语法格式：test Source, Destination\n典型用途：检查一个数中的特定位是否为 1，或判断一个数是否为 0。例如，test %eax, %eax 可以快速判断 %eax 是否为 0。\n影响的标志位：\n\nZF（Zero Flag）：如果按位与的结果为 0，ZF 设为 1；否则为 0。\nSF（Sign Flag）：如果结果的最高位为 1（即负数），SF 设为 1；否则为 0。\nCF 和 OF 会被清零。\n\n\n\n控制流指令\n1. jmp（Unconditional Jump）- 无条件跳转\n\n基本含义：立即、无条件地将程序执行流转移到指定的标签（label）位置。\n语法格式：jmp label\n典型用途：用于 else 块执行后跳过 if 块，或构成循环。\n\n2. jcc（Conditional Jumps）- 条件跳转命令\n\n基本含义：这一系列命令会检查 EFLAGS 寄存器的特定标志位，如果满足条件，则跳转到指定标签；否则，顺序执行下一条指令。\n语法格式：j&lt;condition&gt; label\n\n常见条件跳转命令汇总\n\n\n\n命令\n描述（Jump if…）\n检查的标志位\n适用场景\n\n\n\n\n相等/零\n\n\n\n\n\nje\nEqual（相等）\nZF = 1\na == b\n\n\njne\nNot Equal（不相等）\nZF = 0\na != b\n\n\n有符号比较\n\n\n\n\n\njg\nGreater（大于）\nZF=0 and SF=OF\nsigned a &gt; b\n\n\njge\nGreater or Equal（大于等于）\nSF = OF\nsigned a &gt;= b\n\n\njl\nLess（小于）\nSF ≠ OF\nsigned a &lt; b\n\n\njle\nLess or Equal（小于等于）\nZF=1 or SF≠OF\nsigned a &lt;= b\n\n\n无符号比较\n\n\n\n\n\nja\nAbove（之上）\nCF=0 and ZF=0\nunsigned a &gt; b\n\n\njae\nAbove or Equal（之上或等于）\nCF = 0\nunsigned a &gt;= b\n\n\njb\nBelow（之下）\nCF = 1\nunsigned a &lt; b\n\n\njbe\nBelow or Equal（之下或等于）\nCF=1 or ZF=1\nunsigned a &lt;= b\n\n\n\n3. call / ret (Call / Return)\n\n\n功能: 用于函数（或子程序）的调用和返回。\n\n\ncall: 将下一条指令的地址压入栈中（作为返回地址），然后跳转到函数的起始地址。\n\n\nret: 从栈顶弹出返回地址，并跳转到该地址，从而返回到调用者。\n\n\n示例:\ncall my_function     # 调用名为 my_function 的函数# ... my_function 执行完毕后，会从这里继续执行my_function:    # ... 函数体 ...    ret              # 从函数返回\n\n\n4. cmovcc（Conditional Move，条件传送）指令\n\n基本含义：检查 EFLAGS 寄存器的特定标志位，如果满足条件，则执行 mov Source, Destination 操作。如果标志位不满足条件，该指令就变成一个空操作（NOP），不执行任何数据传送，Destination 的值保持不变。\n语法格式：cmov&lt;condition&gt; Source, Destination\n与条件跳转的对比：cmov 可以避免分支预测失败带来的性能损失，适用于简单的条件赋值。但如果条件分支的逻辑很复杂，使用条件跳转仍然是更好的选择。\n\n条件语句\n高级语言中的条件语句（如 if-else）是通过 cmp 或 test 指令与条件跳转指令（jcc）组合来实现的。其基本思想是：如果条件不满足，就跳过 if 块的代码。\n1. if 语句\nC 语言示例：\n// 假设 a 在 %eax, b 在 %ebxif (a &gt; b) &#123;    // body&#125;// next\n汇编实现：\n    cmp %ebx, %eax   # 比较 a 和 b (eax - ebx)    jle .L_end       # 如果 a &lt;= b (不满足 a &gt; b)，则跳转到结尾# if-body:    ...              # 条件满足时执行的代码.L_end:    ...              # 后续代码\n\n逻辑：先比较，然后使用与条件相反的跳转指令。如果 a &gt; b 的条件不成立（即 a &lt;= b），就跳过 if 的主体部分。\n\n2. if-else 语句\nC 语言示例：\n// 假设 a 在 %eax, b 在 %ebxif (a &gt; b) &#123;    // if-body&#125; else &#123;    // else-body&#125;// next\n汇编实现：\n    cmp %ebx, %eax   # 比较 a 和 b (eax - ebx)    jle .L_else      # 如果 a &lt;= b (不满足 a &gt; b)，则跳转到 else 块# if-body:    ...              # if 块的代码    jmp .L_end       # 执行完 if 块后，无条件跳转到结尾.L_else:# else-body:    ...              # else 块的代码.L_end:    ...              # 后续代码\n\n逻辑：\n\n比较 a 和 b。\n如果 if 的条件不满足，则跳转到 else 块（.L_else）。\n如果 if 的条件满足，则顺序执行 if 块的代码。\nif 块执行完毕后，必须用一个无条件跳转 jmp 来跳过 else 块，防止它被错误地执行。\n\n\n\n3. 使用 cmov 实现条件赋值\n对于简单的条件赋值，现代编译器倾向于使用 cmov 指令来代替条件跳转，以避免分支预测失败的性能开销。\nC 语言示例：\n// 计算 x 和 y 中的较大值int max(int x, int y) &#123;    return x &gt; y ? x : y;&#125;\n汇编实现（使用 cmov）：\n# x 在 %edi, y 在 %esi    movl %esi, %eax    # 先假设 y 是最大值，eax = y    cmpl %esi, %edi    # 比较 x 和 y    cmovg %edi, %eax   # 如果 x &gt; y (greater)，则将 x 的值赋给 eax    ret                # 返回 eax\n\n逻辑：这种实现方式没有跳转，代码是线性的。无论 x 和 y 的大小关系如何，执行的指令数量都是固定的，因此效率更高、更稳定。\n\n","categories":["学习笔记","计算机组成原理"],"tags":["汇编","学习","计算机组成原理"]},{"title":"个人博客搜索引擎收录","url":"/post/1510b461.html","content":"序言\n在搭建好自己的自己的个人博客后，想要让其他人在搜索引擎上搜索到网站上的内容，需要提交网站到搜索引擎的收录平台，并通过添加站点地图来帮助搜索引擎抓取内容。\n站点地图\n站点地图(sitemap)是一种包含了某个网站所有网址的 XML 文件，表明了网页的详细信息和网站的结构框架，添加站点地图可以加速你的网站被搜索引擎爬取。\nHexo 框架生成 Sitemap\n安装hexo-generator-sitemap插件\nnpm install hexo-generator-sitemap --save\n在_configure.yml中添加配置\nsitemap:  path:    - sitemap.xml  rel: false  tags: true  categories: true\n\npath - 网站地图路径。(默认：sitemap.xml)\nrel - 在网站头部添加 rel-sitemap(默认: false)\ntags - 网站的标签\ncategories - 网站的分类\n\n配置好后执行 hexo cl &amp;&amp; hexo g &amp;&amp; hexo d命令生成网站静态文件\n在.deploy_git\\sitemap.xml路径下可查看到默认生成的sitemap.xml文件\n浏览器访问https://&lt;域名&gt;/sitemap.xml也可查看内容\n\n提交站点到谷歌\n到Google search console 提交站点，可以选择多种方式验证您是网站的所有者，这里我选择的是通过添加 DNS 验证，\n\n提交站点地图文件\n\n提交站点到必应\n到 https://www.bing.com/webmasters/ 提交站点，由于之前已经在 Google search console 中添加了网站，这里可以选择从 GSC 直接导入\n同样的，我们这里也提交一下站点地图文件\n\n验证网站是否被搜索引擎收录\n在搜索引擎中输入site:&lt;域名&gt;\n如图所示，我们的网站已经可以在搜索引擎中找到\n\n直接输入我们的网站名称，也可搜索到\n\n","categories":["本站相关"],"tags":["博客","教程"]},{"title":"九月十四日夜行珠江畔","url":"/post/7f55bce6.html","content":"2025-9-14 晚\n夜行珠江畔，迎面江风拂。\n广州市天河区沿江西路\n\n    [{\"url\":\"https://img.angaiing.top/IMG_20250914_214727.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250921_211426.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250921_211932.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250921_211943.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250921_213219.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250914_202420.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250914_205945.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250914_211616.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250914_213224.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250914_213511.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250914_213545.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250914_213611.webp\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://img.angaiing.top/IMG_20250914_214228.webp\",\"alt\":\"\",\"title\":\"\"}]\n  \n","categories":["散步"],"tags":["随手拍"]},{"title":"提示词优化工具","url":"/post/20a60fcb.html","content":"自古以来，对话就是一门艺术和学问，在现实生活中与人对话时，如何让他人准确快速地理解我们所要表达的信息，是提高沟通效率的关键。\n当今的 AI 本质上作为一种接受输入和输出的工具，其基础还是自然语言，想要让 AI 更好的帮助我们，除了模型的基础能力之外，构建准确详细的提示词也是极其重要的。提示词不仅规划限制了 AI 回答的结构和语言风格，也能极大影响其能力的体现。\n当下流行的各类大模型应用，MCP，Agent，RAG……，上下文工程都是最重要的一环之一。再比如酒馆(Silly Tavern)，什么破限预设，世界书，角色卡等等，都把提示词玩出花来了（果然涩涩是第一源动力啊）。\n在此分享一个非常好用的工具 prompt-optimizer，一个提示词优化器，还在苦恼该如何撰写准确详细的 prompt 吗？这个 github 上的开源项目内置了多种提示词优化模板，只需要配置好 API，输入你的原始 prompt，就可以使用 AI 来优化你的提示词。\n\n","categories":["杂谈"],"tags":["杂谈","AI"]}]