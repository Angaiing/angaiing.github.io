---
title: 计组——汇编学习笔记
categories:
  - 学习笔记
  - 计组
  - 汇编
tags:
  - 计组
  - 汇编
  - 学习
abbrlink: 3a831366
date: 2025-10-20 11:59:11
---

# 计组——汇编学习

本文与著名的《深入理解计算机系统》（CS:APP）一书一样，汇编代码格式采用 **AT&T 格式**。

## AT&T 格式与 Intel 格式的不同

| 特性             | AT&T 格式                                                     | Intel 格式                                                        |
| :--------------- | :------------------------------------------------------------ | :---------------------------------------------------------------- |
| **操作数顺序**   | `op s,d`<br>源在左，目标在右                                  | `op d,s`<br>目标在左，源在右                                      |
| **寄存器表示**   | `mov %ebx,%eax`<br>寄存器名称前加 `%`                         | `mov ebx,eax`<br>不带前缀                                         |
| **立即数表示**   | `mov $985,%eax`<br>立即数前加 `$`                             | `mov 985,%eax`<br>不带前缀                                        |
| **主存地址表示** | `(af996h)`<br>用小括号                                        | `[af996h]`<br>用中括号                                            |
| **读写长度表示** | `movl`，`movq`<br>`b`、`w`、`l`、`q` 分别表示 1、2、4、8 字节 | `mov byte ptr [af996h],5`<br>在主存地址前说明读写长度             |
| **主存偏移表示** | `偏移(基址, 索引, 缩放)`<br>`8(%ebp)`<br>`(%eax, %ebx, 4)`    | `[基址 + 索引 * 缩放 + 偏移]`<br>`[ebp + 8]`<br>`[eax + ebx * 4]` |
| **注释**         | `#`                                                           | `;`                                                               |

## 内存寻址

在 AT&T 语法中，一个完整的内存地址表达式格式为：

$$
D(R_b, R_i, S)
$$

计算出的内存地址为：

$$
\text{内存地址} = D + R_b + R_i \times S
$$

**各部分的含义：**

- **$D$（Displacement / 偏移量）**：一个**常数值**（例如 `8`、`-12`，或标签 `my_var` 的地址），类似于“基础”的门牌号。
- **$R_b$（Base Register / 基址寄存器）**：一个寄存器（例如 `%ebp`、`%eax`、`%rbx`），提供“动态的”基准地址，如函数栈帧的开始或数组的开头。
- **$R_i$（Index Register / 索引寄存器）**：另一个寄存器（例如 `%ecx`、`%eax`），通常用于存储“索引”值，如循环变量 `i`。
- **$S$（Scale / 缩放因子）**：一个**固定的**乘数，**值必须是 1、2、4 或 8**。它配合索引（$R_i$）使用。如果 $R_i$ 存储数组下标 `i`，而数组元素大小为 4 字节（`int`），则 $S$ 应为 4，这样 `Ri * S` 就等于 `i * 4`，即第 `i` 个元素的字节偏移。

## 常用汇编指令

### 数据传送指令

这类指令负责在寄存器和内存之间移动数据，是所有程序的基础。

#### 1. `mov`（Move）

- **功能**：将源操作数的值复制到目标操作数。这是最常用、最重要的指令。

- **AT&T 格式**：`movl source, destination`

- **示例**：

  ```assembly
  movl %eax, %ebx      # 将寄存器 %eax 的值复制到 %ebx
  movl $10, %eax       # 将立即数 10 存入寄存器 %eax
  movl (%ebx), %eax    # 将 %ebx 寄存器指向的内存地址中的数据加载到 %eax
  movl %eax, -4(%rbp)  # 将 %eax 的值存入栈上地址为 %rbp-4 的位置
  ```

#### 2. `lea`（Load Effective Address）

- **功能**：计算源操作数（必须是内存地址）的有效地址，并将其加载到目标操作数（必须是寄存器）。它传送的是地址本身，而不是地址指向的数据。

- **AT&T 格式**：`leaq source_address, destination_register`

- **示例**：

  ```assembly
  leaq -8(%rbp), %rax  # 将内存地址 %rbp-8 这个地址值本身加载到 %rax 寄存器
                       # 这条指令执行后，%rax 的值就是 %rbp 的值减 8
  ```

- **说明**：`lea` 指令非常灵活，常被用来进行不影响标志位的快速算术运算。

#### 3. `push` / `pop`（Push / Pop）

- **功能**：在栈上压入或弹出数据。栈是“后进先出”（LIFO）的数据结构，在函数调用中至关重要。

- **`push`**：将操作数压入栈顶，栈指针 `%rsp` 会减小。

- **`pop`**：从栈顶弹出一个数据到操作数，栈指针 `%rsp` 会增大。

- **AT&T 格式**：`pushq source` / `popq destination`

- **示例**：

  ```assembly
  pushq %rbx           # 将 %rbx 的值压入栈顶
  popq %rax            # 从栈顶弹出一个值到 %rax
  ```

### 算术运算指令

用于执行基本的数学计算。

#### 1. `add` / `sub`（Add / Subtract）

- **功能**：加法和减法。

- **AT&T 格式**：`addl source, destination`（结果：`destination = destination + source`）

- **示例**：

  ```assembly
  addl %eax, %ebx      # %ebx = %ebx + %eax
  subl $5, %ecx        # %ecx = %ecx - 5
  ```

#### 2. `inc` / `dec`（Increment / Decrement）

- **功能**：将操作数加一或减一。比 `add` 或 `sub` 更高效。

- **AT&T 格式**：`incl destination`

- **示例**：

  ```assembly
  incl %eax            # %eax = %eax + 1
  decq %rbx            # %rbx = %rbx - 1
  ```

#### 3. `imul`（Signed Multiply）

- **功能**：有符号整数乘法。

- **AT&T 格式**：`imull source, destination`（结果：`destination = destination * source`）

- **示例**：

  ```assembly
  imull %ebx, %eax     # %eax = %eax * %ebx
  ```

#### 4. `idiv`（Signed Divide）

- **功能**：有符号整数除法。这个指令比较特殊。

- **AT&T 格式**：`idivl divisor`

- **说明**：`idiv` 会使用 `%edx:%eax`（一个 64 位数）作为被除数，除数是指令的操作数。**商**存储在 `%eax` 中，**余数**存储在 `%edx` 中。

- **示例**：

  ```assembly
  cqto                 # 64 位模式下，将 %rax 符号扩展到 %rdx:%rax
  idivq %rbx           # (%rdx:%rax) / %rbx，商在 %rax，余数在 %rdx
  ```

- **注意**：在执行 32 位除法 `idivl` 前，通常需要 `cdq` 指令将 `%eax` 符号扩展到 `%edx`。

### 逻辑与比较指令

#### 1. `and` / `or` / `xor` (Bitwise AND / OR / XOR)

- **功能**: 按位进行与、或、异或运算。

- **AT&T 格式**: `andl source, destination` (结果: `destination = destination & source`)

- **示例**:

  ```assembly
  andl $0xf, %eax      # 清零 %eax 的高28位，保留低4位
  xorl %eax, %eax      # 一种将 %eax 清零的高效方法
  ```

#### 2. `cmp`（Compare）

- **基本含义**：`cmp` 指令对两个操作数执行一次“隐藏”的减法操作（`Destination - Source`），但不保存结果，仅根据结果设置 `EFLAGS` 寄存器中的标志位。
- **语法格式**：`cmp Source, Destination`
- **影响的标志位**：
  - **ZF（Zero Flag - 零标志位）**：如果相减结果为 0（即两个数相等），ZF 设为 1；否则为 0。
  - **SF（Sign Flag - 符号标志位）**：如果结果为负数，SF 设为 1；否则为 0。
  - **CF（Carry Flag - 进位标志位）**：用于无符号数比较。如果减法产生了借位（`Destination < Source`），CF 设为 1。
  - **OF（Overflow Flag - 溢出标志位）**：用于有符号数比较。如果减法导致有符号溢出，OF 设为 1。

#### 3. `test`（Test）

- **基本含义**：`test` 指令对两个操作数执行“隐藏”的按位与操作（`Destination & Source`），但不保存结果，仅根据结果设置标志位。
- **语法格式**：`test Source, Destination`
- **典型用途**：检查一个数中的特定位是否为 1，或判断一个数是否为 0。例如，`test %eax, %eax` 可以快速判断 `%eax` 是否为 0。
- **影响的标志位**：
  - **ZF（Zero Flag）**：如果按位与的结果为 0，ZF 设为 1；否则为 0。
  - **SF（Sign Flag）**：如果结果的最高位为 1（即负数），SF 设为 1；否则为 0。
  - **CF 和 OF** 会被清零。

### 控制流指令

#### 1. `jmp`（Unconditional Jump）- 无条件跳转

- **基本含义**：立即、无条件地将程序执行流转移到指定的标签（label）位置。
- **语法格式**：`jmp label`
- **典型用途**：用于 `else` 块执行后跳过 `if` 块，或构成循环。

#### 2. `jcc`（Conditional Jumps）- 条件跳转命令

- **基本含义**：这一系列命令会检查 `EFLAGS` 寄存器的特定标志位，如果满足条件，则跳转到指定标签；否则，顺序执行下一条指令。
- **语法格式**：`j<condition> label`

#### 常见条件跳转命令汇总

| 命令           | 描述（Jump if...）           | 检查的标志位   | 适用场景          |
| :------------- | :--------------------------- | :------------- | :---------------- |
| **相等/零**    |                              |                |                   |
| `je`           | Equal（相等）                | ZF = 1         | `a == b`          |
| `jne`          | Not Equal（不相等）          | ZF = 0         | `a != b`          |
| **有符号比较** |                              |                |                   |
| `jg`           | Greater（大于）              | ZF=0 and SF=OF | `signed a > b`    |
| `jge`          | Greater or Equal（大于等于） | SF = OF        | `signed a >= b`   |
| `jl`           | Less（小于）                 | SF ≠ OF        | `signed a < b`    |
| `jle`          | Less or Equal（小于等于）    | ZF=1 or SF≠OF  | `signed a <= b`   |
| **无符号比较** |                              |                |                   |
| `ja`           | Above（之上）                | CF=0 and ZF=0  | `unsigned a > b`  |
| `jae`          | Above or Equal（之上或等于） | CF = 0         | `unsigned a >= b` |
| `jb`           | Below（之下）                | CF = 1         | `unsigned a < b`  |
| `jbe`          | Below or Equal（之下或等于） | CF=1 or ZF=1   | `unsigned a <= b` |

#### 3. `call` / `ret` (Call / Return)

- **功能**: 用于函数（或子程序）的调用和返回。

- **`call`**: 将下一条指令的地址压入栈中（作为返回地址），然后跳转到函数的起始地址。

- **`ret`**: 从栈顶弹出返回地址，并跳转到该地址，从而返回到调用者。

- **示例**:

  ```assembly
  call my_function     # 调用名为 my_function 的函数
  # ... my_function 执行完毕后，会从这里继续执行

  my_function:
      # ... 函数体 ...
      ret              # 从函数返回
  ```

#### 4. `cmovcc`（Conditional Move，条件传送）指令

- **基本含义**：检查 `EFLAGS` 寄存器的特定标志位，如果满足条件，则执行 `mov Source, Destination` 操作。如果标志位不满足条件，该指令就变成一个空操作（NOP），不执行任何数据传送，`Destination` 的值保持不变。
- **语法格式**：`cmov<condition> Source, Destination`
- **与条件跳转的对比**：`cmov` 可以避免分支预测失败带来的性能损失，适用于简单的条件赋值。但如果条件分支的逻辑很复杂，使用条件跳转仍然是更好的选择。

## 条件语句

高级语言中的条件语句（如 `if-else`）是通过 `cmp` 或 `test` 指令与条件跳转指令（`jcc`）组合来实现的。其基本思想是：**如果条件不满足，就跳过 `if` 块的代码**。

### 1. `if` 语句

**C 语言示例：**

```c
// 假设 a 在 %eax, b 在 %ebx
if (a > b) {
    // body
}
// next
```

**汇编实现：**

```assembly
    cmp %ebx, %eax   # 比较 a 和 b (eax - ebx)
    jle .L_end       # 如果 a <= b (不满足 a > b)，则跳转到结尾
# if-body:
    ...              # 条件满足时执行的代码
.L_end:
    ...              # 后续代码
```

- **逻辑**：先比较，然后使用与条件**相反**的跳转指令。如果 `a > b` 的条件**不**成立（即 `a <= b`），就跳过 `if` 的主体部分。

### 2. `if-else` 语句

**C 语言示例：**

```c
// 假设 a 在 %eax, b 在 %ebx
if (a > b) {
    // if-body
} else {
    // else-body
}
// next
```

**汇编实现：**

```assembly
    cmp %ebx, %eax   # 比较 a 和 b (eax - ebx)
    jle .L_else      # 如果 a <= b (不满足 a > b)，则跳转到 else 块
# if-body:
    ...              # if 块的代码
    jmp .L_end       # 执行完 if 块后，无条件跳转到结尾
.L_else:
# else-body:
    ...              # else 块的代码
.L_end:
    ...              # 后续代码
```

- **逻辑**：
  1.  比较 `a` 和 `b`。
  2.  如果 `if` 的条件**不**满足，则跳转到 `else` 块（`.L_else`）。
  3.  如果 `if` 的条件满足，则顺序执行 `if` 块的代码。
  4.  `if` 块执行完毕后，必须用一个**无条件跳转 `jmp`** 来跳过 `else` 块，防止它被错误地执行。

### 3. 使用 `cmov` 实现条件赋值

对于简单的条件赋值，现代编译器倾向于使用 `cmov` 指令来代替条件跳转，以避免分支预测失败的性能开销。

**C 语言示例：**

```c
// 计算 x 和 y 中的较大值
int max(int x, int y) {
    return x > y ? x : y;
}
```

**汇编实现（使用 `cmov`）：**

```assembly
# x 在 %edi, y 在 %esi
    movl %esi, %eax    # 先假设 y 是最大值，eax = y
    cmpl %esi, %edi    # 比较 x 和 y
    cmovg %edi, %eax   # 如果 x > y (greater)，则将 x 的值赋给 eax
    ret                # 返回 eax
```

- **逻辑**：这种实现方式没有跳转，代码是线性的。无论 `x` 和 `y` 的大小关系如何，执行的指令数量都是固定的，因此效率更高、更稳定。
